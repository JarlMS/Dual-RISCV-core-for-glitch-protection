\chapter{Appendix 1 - Code}
\label{app:appx1}

Any source code referenced in the project is shown in this appendix.

\section{Sanity test for the CV32E40S core}
\label{app:helloworldC}

\lstset{ 
   language=C,                   % choose the language of the code
   breaklines=true,                % sets automatic line breaking
   breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
}
\begin{lstlisting}[caption={Sanity test for the CV32E40S core.}, label=lst:sample_code]
    /*
**
** Copyright 2020 OpenHW Group
**
** Licensed under the Solderpad Hardware Licence, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     https://solderpad.org/licenses/
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
*******************************************************************************
**
** Sanity test for the CV32E40S core.  Reads the MVENDORID, MISA, MARCHID and
**                                     MIMPID CSRs and prints some useful (?)
**                                     messages to stdout.  Will fail if these
**                                     CSRs do not match expected values.
**
*******************************************************************************
*/

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

#define EXP_MISA 0x40901104

int main(int argc, char *argv[])
{

    volatile unsigned int misa_rval, mvendorid_rval, marchid_rval, mimpid_rval, mxl;
    volatile          int reserved, tentative, nonstd, user, super;

    mxl = 0; reserved = 0; tentative = 0; nonstd = 0; user = 0; super = 0;

    /* inline assembly: read mvendorid and misa */
    __asm__ volatile("csrr %0, 0xF11" : "=r"(mvendorid_rval));
    __asm__ volatile("csrr %0, 0x301" : "=r"(misa_rval));
    __asm__ volatile("csrr %0, 0xF12" : "=r"(marchid_rval));
    __asm__ volatile("csrr %0, 0xF13" : "=r"(mimpid_rval));

    /* Check MVENDORID CSR: 0x602 is the value assigned by JEDEC to the OpenHW Group */
    if (mvendorid_rval != 0x00000602) {
      printf("\tERROR: CSR MVENDORID reads as 0x%x - should be 0x00000602 for the OpenHW Group.\n\n", mvendorid_rval);
      return EXIT_FAILURE;
    }

    /* Check MISA CSR: if its zero, it might not be implemented at all */
    if (misa_rval != EXP_MISA) {
      printf("\tERROR: CSR MISA reads as 0x%x - should be 0x%x for this release of CV32E40S!\n\n", misa_rval, EXP_MISA);
      return EXIT_FAILURE;
    }

    /* Check MARCHID CSR: 0x15 is the value assigned by the RISC-V Foundation to CV32E40S */
    if (marchid_rval != 0x15) {
      printf("\tERROR: CSR MARCHID reads as 0x%x - should be 0x00000015 for CV32E40S.\n\n", marchid_rval);
      return EXIT_FAILURE;
    }

    /* Check MIMPID CSR: 0x0 is the value assigned by the OpenHW Group to the first release of CV32E40S */
    if (mimpid_rval != 0x00000000) {
      printf("\tERROR: CSR MIMPID reads as 0x%x - should be 0x00000000 for this release of CV32E40S.\n\n", mimpid_rval);
      return EXIT_FAILURE;
    }

    /* Print a banner to stdout and interpret MISA CSR */
    printf("\nHELLO WORLD!!!\n");
    printf("This is the OpenHW Group CV32E40S CORE-V processor core.\n");
    printf("CV32E40S is a RISC-V ISA compliant core with the following attributes:\n");
    printf("\tmvendorid = 0x%x\n", mvendorid_rval);
    printf("\tmarchid   = 0x%x\n", marchid_rval);
    printf("\tmimpid    = 0x%x\n", mimpid_rval);
    printf("\tmisa      = 0x%x\n", misa_rval);
    mxl = ((misa_rval & 0xC0000000) >> 30); // MXL == MISA[31:30]
    switch (mxl) {
      case 0:  printf("\tERROR: MXL cannot be zero!\n");
               return EXIT_FAILURE;
               break;
      case 1:  printf("\tXLEN is 32-bits\n");
               break;
      case 2:  printf("\tXLEN is 64-bits\n");
               break;
      case 3:  printf("\tXLEN is 128-bits\n");
               break;
      default: printf("\tERROR: mxl (%0d) not in 0..3, your code is broken!\n", mxl);
               return EXIT_FAILURE;
    }

    printf("\tSupported Instructions Extensions: ");
    if ((misa_rval >> 25) & 0x00000001) ++reserved;
    if ((misa_rval >> 24) & 0x00000001) ++reserved;
    if ((misa_rval >> 23) & 0x00000001) {
      printf("X");
      ++nonstd;
    }
    if ((misa_rval >> 22) & 0x00000001) ++reserved;
    if ((misa_rval >> 21) & 0x00000001) ++tentative;
    if ((misa_rval >> 20) & 0x00000001) ++user;
    if ((misa_rval >> 19) & 0x00000001) ++tentative;
    if ((misa_rval >> 18) & 0x00000001) ++super;
    if ((misa_rval >> 17) & 0x00000001) ++reserved;
    if ((misa_rval >> 16) & 0x00000001) printf("Q");
    if ((misa_rval >> 15) & 0x00000001) ++tentative;
    if ((misa_rval >> 14) & 0x00000001) ++reserved;
    if ((misa_rval >> 13) & 0x00000001) printf("N");
    if ((misa_rval >> 12) & 0x00000001) printf("M");
    if ((misa_rval >> 11) & 0x00000001) ++tentative;
    if ((misa_rval >> 10) & 0x00000001) ++reserved;
    if ((misa_rval >>  9) & 0x00000001) printf("J");
    if ((misa_rval >>  8) & 0x00000001) printf("I");
    if ((misa_rval >>  7) & 0x00000001) printf("H");
    if ((misa_rval >>  6) & 0x00000001) printf("G");
    if ((misa_rval >>  5) & 0x00000001) printf("F");
    if ((misa_rval >>  4) & 0x00000001) printf("E");
    if ((misa_rval >>  3) & 0x00000001) printf("D");
    if ((misa_rval >>  2) & 0x00000001) printf("C");
    if ((misa_rval >>  1) & 0x00000001) printf("B");
    if ((misa_rval      ) & 0x00000001) printf("A");
    printf("\n");
    if (super) {
      printf("\tThis machine supports SUPERVISOR mode.\n");
    }
    if (user) {
      printf("\tThis machine supports USER mode.\n");
    }
    if (nonstd) {
      printf("\tThis machine supports non-standard instructions.\n");
    }
    if (tentative) {
      printf("\tWARNING: %0d tentative instruction extensions are defined!\n", tentative);
    }
    if (reserved) {
      printf("\tERROR: %0d reserved instruction extensions are defined!\n\n", reserved);
      return EXIT_FAILURE;
    }
    else {
      printf("\n");
      return EXIT_SUCCESS;
    }
}

\end{lstlisting}

% Define RISC-V Assembly language style
\lstdefinelanguage{riscv}{
  morekeywords={add,sub,li,lw,sw,nop,push,addi4spn,jal,beqz,addi,bgeu,j,mv,popret}, % Add your RISC-V instructions
  sensitive=false,
  morecomment=[l]{\#},
  morestring=[b]",
}


\begin{lstlisting}[caption={Assembly code for instruction skip test program}, label=lst:asm_instr_skip, language=riscv]
00000438 <main>:

int main(int argc, char *argv[])
{
     438:	b85a                    cm.push {x1,x8},-48
     43a:	1800                    c.addi4spn	x8,x2,48
     43c:	fca42e23                sw	x10,-36(x8)
     440:	fcb42c23                sw	x11,-40(x8)
    /* Print a banner to stdout */
    // printf("\nHello World! This is the new glitch test\n");
    int result_code = 0;
     444:	fe042423                sw	x0,-24(x8)

    /* Count to avoid actual infite loop */
    unsigned int count = 0;
     448:	fe042623                sw	x0,-20(x8)

    /* Get error result code */
    result_code = boot_go();
     44c:	37f1                    c.jal   418 <boot_go>
     44e:	fea42423                sw	x10,-24(x8)

    if (result_code != 0) {
     452:	fe842783                lw	x15,-24(x8)
     456:	c395                    c.beqz  x15,47a <main+0x42>
      // printf("Unable to find bootable image\n");
      while(1) {
        count++;
     458:	fec42783                lw	x15,-20(x8)
     45c:	0785                    c.addi  x15,1
     45e:	fef42623                sw	x15,-20(x8)
        if (count > 10) {
     462:	fec42703                lw	x14,-20(x8)
     466:	47a9                    c.li    x15,10
     468:	fee7f8e3                bgeu    x15,x14,458 <main+0x20>
          printf("Exiting...\n");
     46c:	6791                    c.lui   x15,0x4
     46e:	84c78513                addi    x10,x15,-1972 # 384c <nmi_end_handler_ret+0x28>
     472:	05b000ef                jal     x1,ccc <puts>
          return EXIT_SUCCESS;
     476:	4781                    c.li    x15,0
     478:	a801                    c.j     488 <main+0x50>
        }
      }
    }

    printf("Glitched out of loop\n");
     47a:	6791                    c.lui   x15,0x4
     47c:	85878513                addi    x10,x15,-1960 # 3858 <nmi_end_handler_ret+0x34>
     480:	04d000ef                jal     x1,ccc <puts>
    do_boot();
     484:	3755                    c.jal   428 <do_boot>
    return EXIT_FAILURE;
     486:	4785                    c.li    x15,1
}
     488:	853e                    c.mv    x10,x15
     48a:	be5a                    cm.popret	{x1,x8},48

\end{lstlisting}

\begin{lstlisting}[caption={Assembly code for coverage test program}, label=lst:asm_coverage, language=riscv]

00000418 <main>:
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
     418:	b85a                    cm.push {x1,x8},-48
     41a:       1800                    c.addi4spn	x8,x2,48
     41c:	fca42e23                sw      x10,-36(x8)
     420:	fcb42c23                sw      x11,-40(x8)
    int prev = 0;
     424:       fe042623                sw	x0,-20(x8)
    int current = 1;
     428:	4785                    c.li    x15,1
     42a:	fef42423                sw      x15,-24(x8)

    for (int i = 1; i < 20; i++) {
     42e:       4785                    c.li    x15,1
     430:       fef42223                sw	x15,-28(x8)
     434:       a02d                    c.j     45e <main+0x46>
        int next = prev + current;
     436:	fec42703                lw	x14,-20(x8)
     43a:	fe842783                lw	x15,-24(x8)
     43e:	97ba                    c.add   x15,x14
     440:	fef42023                sw	x15,-32(x8)
        prev = current;
     444:	fe842783                lw	x15,-24(x8)
     448:	fef42623                sw	x15,-20(x8)
        current = next;
     44c:	fe042783                lw	x15,-32(x8)
     450:	fef42423                sw	x15,-24(x8)
    for (int i = 1; i < 20; i++) {
     454:	fe442783                lw	x15,-28(x8)
     458:	0785                    c.addi  x15,1
     45a:	fef42223                sw	x15,-28(x8)
     45e:	fe442703                lw	x14,-28(x8)
     462:	47cd                    c.li    x15,19
     464:	fce7d9e3                bge     x15,x14,436 <main+0x1e>
    }

    if (current == 6765) {
     468:	fe842703                lw	x14,-24(x8)
     46c:	6789                    c.lui   x15,0x2
     46e:	a6d78793                addi    x15,x15,-1427 # 1a6d <__sfvwrite_r+0x35d>
     472:	00f71963                bne     x14,x15,484 <main+0x6c>
        printf("No glitch detected\n");
     476:	6791                    c.lui   x15,0x4
     478:	85478513                addi    x10,x15,-1964 # 3854 <nmi_end_handler_ret+0x28>
     47c:	059000ef                jal     x1,cd4 <puts>
        return EXIT_SUCCESS;
     480:	4781                    c.li    x15,0
     482:	a039                    c.j     490 <main+0x78>
    }
    printf("Glitch detected\n");
     484:	6791                    c.lui   x15,0x4
     486:	86878513                addi    x10,x15,-1944 # 3868 <nmi_end_handler_ret+0x3c>
     48a:	04b000ef                jal     x1,cd4 <puts>
    return EXIT_FAILURE;
     48e:	4785                    c.li    x15,1
}
     490:	853e                    c.mv    x10,x15
     492:	be5a                    cm.popret	{x1,x8},48
\end{lstlisting}


\begin{lstlisting}[caption={CV32E40DC wrapper code}, label=lst:dc_wrapper, language=verilog]

    // Instantiate the dual core wrapper 
    cv32e40dc_core
        #(
          .LIB                   ( LIB                   ),
          .RV32                  ( RV32                  ),
          .B_EXT                 ( B_EXT                 ),
          .M_EXT                 ( M_EXT                 ),
          .PMP_GRANULARITY       ( PMP_GRANULARITY       ),
          .PMP_NUM_REGIONS       ( PMP_NUM_REGIONS       ),
          .PMP_PMPNCFG_RV        ( PMP_PMPNCFG_RV        ),
          .PMP_PMPADDR_RV        ( PMP_PMPADDR_RV        ),
          .PMP_MSECCFG_RV        ( PMP_MSECCFG_RV        ),
          .CLIC                  ( CLIC                  ),
          .CLIC_ID_WIDTH         ( CLIC_ID_WIDTH         ),
          .DEBUG                 ( DEBUG                 ),
          .DM_REGION_START       ( DM_REGION_START       ),
          .DM_REGION_END         ( DM_REGION_END         ),
          .DBG_NUM_TRIGGERS      ( DBG_NUM_TRIGGERS      ),
          .PMA_NUM_REGIONS       ( PMA_NUM_REGIONS       ),
          .PMA_CFG               ( PMA_CFG               ),
          .LFSR0_CFG             ( LFSR0_CFG             ),
          .LFSR1_CFG             ( LFSR1_CFG             ),
          .LFSR2_CFG             ( LFSR2_CFG             ))
    core_i (.*);

    // Glitching signals 
    reg glitch_enable;
    wire glitch_enable_specific;
    logic [31:0] glitch_out;

    cv32e40s_glitch_injector 
      #(
        32,
        32'h0000673c
        )
    glitch_injector_i (
      .enable           (1'b1),
      .enable_specific  (1'b1),
      .clk              (clk_i),
      .rst_n            (rst_ni),
      .out              (glitch_out),
      .in               (core_i.if_id_pipe.pc)
    );

\end{lstlisting}

\begin{lstlisting}[caption={Dual core code with synchronization registers. Written with assistance from ChatGPT.}, label=lst:dc_code, language=verilog, literate={<=}{{$<=$}}1]                                                                                    

  // Static configuration
  logic [31:0]                   boot_addr_i_cmp;
  logic [31:0]                   dm_exception_addr_i_cmp;
  logic [31:0]                   dm_halt_addr_i_cmp;
  logic [31:0]                   mhartid_i_cmp;
  logic  [3:0]                   mimpid_patch_i_cmp;
  logic [31:0]                   mtvec_addr_i_cmp;

  // Instruction memory interface
  logic                          instr_req_o_cmp;
  logic                          instr_gnt_i_cmp;
  logic                          instr_rvalid_i_cmp;
  logic [31:0]                   instr_addr_o_cmp;
  logic [1:0]                    instr_memtype_o_cmp;
  logic [2:0]                    instr_prot_o_cmp;
  logic                          instr_dbg_o_cmp;
  logic [31:0]                   instr_rdata_i_cmp;
  logic                          instr_err_i_cmp;

  logic                          instr_reqpar_o_cmp;         // secure
  logic                          instr_gntpar_i_cmp;         // secure
  logic                          instr_rvalidpar_i_cmp;      // secure
  logic [12:0]                   instr_achk_o_cmp;           // secure
  logic [4:0]                    instr_rchk_i_cmp;           // secure

  // Data memory interface
  logic                          data_req_o_cmp;
  logic                          data_gnt_i_cmp;
  logic                          data_rvalid_i_cmp;
  logic [31:0]                   data_addr_o_cmp;
  logic [3:0]                    data_be_o_cmp;
  logic                          data_we_o_cmp;
  logic [31:0]                   data_wdata_o_cmp;
  logic [1:0]                    data_memtype_o_cmp;
  logic [2:0]                    data_prot_o_cmp;
  logic                          data_dbg_o_cmp;
  logic [31:0]                   data_rdata_i_cmp;
  logic                          data_err_i_cmp;

  logic                          data_reqpar_o_cmp;          // secure
  logic                          data_gntpar_i_cmp;          // secure
  logic                          data_rvalidpar_i_cmp;       // secure
  logic [12:0]                   data_achk_o_cmp;            // secure
  logic [4:0]                    data_rchk_i_cmp;            // secure

  // Cycle count
  logic [63:0]                   mcycle_o_cmp;

  // Basic interrupt architecture
  logic [31:0]                   irq_i_cmp;

  // Event wakeup signals
  logic                          wu_wfe_i_cmp;   // Wait-for-event wakeup

  // CLIC interrupt architecture
  logic                          clic_irq_i_cmp;
  logic [CLIC_ID_WIDTH-1:0]      clic_irq_id_i_cmp;
  logic [ 7:0]                   clic_irq_level_i_cmp;
  logic [ 1:0]                   clic_irq_priv_i_cmp;
  logic                          clic_irq_shv_i_cmp;

  // Fence.i flush handshake
  logic                          fencei_flush_req_o_cmp;
  logic                          fencei_flush_ack_i_cmp;

    // Security Alerts
  logic                          alert_minor_o_cmp;          // secure
  logic                          alert_major_o_cmp;          // secure

  // Debug interface
  logic                          debug_req_i_cmp;
  logic                          debug_havereset_o_cmp;
  logic                          debug_running_o_cmp;
  logic                          debug_halted_o_cmp;
  logic                          debug_pc_valid_o_cmp;
  logic [31:0]                   debug_pc_o_cmp;

  // CPU control signals
  logic                          fetch_enable_i_cmp;
  logic                          core_sleep_o_cmp;

  // Comparison outputs 
  if_id_pipe_t                   if_id_compare_o_cmp;
  id_ex_pipe_t                   id_ex_compare_o_cmp;
  ex_wb_pipe_t                   ex_wb_compare_o_cmp;

  // Register for output form main core
  logic         instr_req_o_reg;         
  logic [31:0]  instr_addr_o_reg;        
  logic [1:0]   instr_memtype_o_reg;     
  logic [2:0]   instr_prot_o_reg;        
  logic         instr_dbg_o_reg;         
  logic         instr_reqpar_o_reg;      
  logic [12:0]  instr_achk_o_reg;        

  logic         data_req_o_reg;          
  logic [31:0]  data_addr_o_reg;         
  logic [3:0]   data_be_o_reg;           
  logic         data_we_o_reg;           
  logic [31:0]  data_wdata_o_reg;        
  logic [1:0]   data_memtype_o_reg;      
  logic [2:0]   data_prot_o_reg;           
  logic         data_dbg_o_reg;          
  logic         data_reqpar_o_reg;       
  logic [12:0]  data_achk_o_reg;       

  logic [63:0]  mcycle_o_reg;  

  logic         fencei_flush_req_o_reg;  

  logic         alert_minor_o_reg;       
  logic         alert_major_o_reg;

  logic         debug_havereset_o_reg;   
  logic         debug_running_o_reg;     
  logic         debug_halted_o_reg;      
  logic         debug_pc_valid_o_reg;    
  logic [31:0]  debug_pc_o_reg;       

  logic [31:0]  core_sleep_o_reg;   

  if_id_pipe_t  if_id_compare_o_reg;     
  id_ex_pipe_t  id_ex_compare_o_reg;    
  ex_wb_pipe_t  ex_wb_compare_o_reg;     

always_ff @(posedge clk_i or negedge rst_ni) begin
  if (!rst_ni) begin 
    // Registers for holding input data going to comparison core
    boot_addr_i_cmp         <= 0;
    dm_exception_addr_i_cmp <= 0;
    dm_halt_addr_i_cmp      <= 0;
    mhartid_i_cmp           <= 0;
    mimpid_patch_i_cmp      <= 0;
    mtvec_addr_i_cmp        <= 0;
    instr_gnt_i_cmp         <= 0;
    instr_rvalid_i_cmp      <= 0;
    instr_rdata_i_cmp       <= 0;
    instr_err_i_cmp         <= 0;
    instr_gntpar_i_cmp      <= 0;         // secure
    instr_rvalidpar_i_cmp   <= 0;      // secure
    instr_rchk_i_cmp        <= 0;           // secure
    data_gnt_i_cmp          <= 0;
    data_rvalid_i_cmp       <= 0;
    data_rdata_i_cmp        <= 0;
    data_err_i_cmp          <= 0;
    data_gntpar_i_cmp       <= 0;          // secure
    data_rvalidpar_i_cmp    <= 0;       // secure
    data_rchk_i_cmp         <= 0;            // secure
    irq_i_cmp               <= 0;
    wu_wfe_i_cmp            <= 0;   // Wait-for-event wakeup
    clic_irq_i_cmp          <= 0;
    clic_irq_id_i_cmp       <= 0;
    clic_irq_level_i_cmp    <= 0; 
    clic_irq_priv_i_cmp     <= 0;
    clic_irq_shv_i_cmp      <= 0;
    fencei_flush_ack_i_cmp  <= 0;
    debug_req_i_cmp         <= 0;
    fetch_enable_i_cmp      <= 0;

    // Registers for holding output data from main core 
    instr_req_o_reg         <= 0;
    instr_addr_o_reg        <= 0;
    instr_memtype_o_reg     <= 0;
    instr_prot_o_reg        <= 0;
    instr_dbg_o_reg         <= 0;
    instr_reqpar_o_reg      <= 0;
    instr_achk_o_reg        <= 0;
    data_req_o_reg          <= 0;  
    data_addr_o_reg         <= 0;
    data_be_o_reg           <= 0;
    data_we_o_reg           <= 0;
    data_wdata_o_reg        <= 0;
    data_memtype_o_reg      <= 0;
    data_prot_o_reg         <= 0;
    data_dbg_o_reg          <= 0;
    data_reqpar_o_reg       <= 0;
    data_achk_o_reg         <= 0;
    mcycle_o_reg            <= 0;
    fencei_flush_req_o_reg  <= 0;
    alert_minor_o_reg       <= 0;
    alert_major_o_reg       <= 0;
    debug_havereset_o_reg   <= 0;
    debug_running_o_reg     <= 0;
    debug_halted_o_reg      <= 0;
    debug_pc_valid_o_reg    <= 0;
    debug_pc_o_reg          <= 0;
    core_sleep_o_reg        <= 0;
    if_id_compare_o_reg     <= 0;
    id_ex_compare_o_reg     <= 0;
    ex_wb_compare_o_reg     <= 0;
  end
  else begin
    // Registers for holding input data going to comparison core
    boot_addr_i_cmp         <= boot_addr_i;
    dm_exception_addr_i_cmp <= dm_exception_addr_i;
    dm_halt_addr_i_cmp      <= dm_halt_addr_i;
    mhartid_i_cmp           <= mhartid_i;
    mimpid_patch_i_cmp      <= mimpid_patch_i;
    mtvec_addr_i_cmp        <= mtvec_addr_i;
    instr_gnt_i_cmp         <= instr_gnt_i;
    instr_rvalid_i_cmp      <= instr_rvalid_i;
    instr_rdata_i_cmp       <= instr_rdata_i;
    instr_err_i_cmp         <= instr_err_i;
    instr_gntpar_i_cmp      <= instr_gntpar_i;         // secure
    instr_rvalidpar_i_cmp   <= instr_rvalidpar_i;      // secure
    instr_rchk_i_cmp        <= instr_rchk_i;           // secure
    data_gnt_i_cmp          <= data_gnt_i;
    data_rvalid_i_cmp       <= data_rvalid_i;
    data_rdata_i_cmp        <= data_rdata_i;
    data_err_i_cmp          <= data_err_i;
    data_gntpar_i_cmp       <= data_gntpar_i;          // secure
    data_rvalidpar_i_cmp    <= data_rvalidpar_i;       // secure
    data_rchk_i_cmp         <= data_rchk_i;            // secure
    irq_i_cmp               <= irq_i;
    wu_wfe_i_cmp            <= wu_wfe_i;   // Wait-for-event wakeup
    clic_irq_i_cmp          <= clic_irq_i;
    clic_irq_id_i_cmp       <= clic_irq_id_i;
    clic_irq_level_i_cmp    <= clic_irq_level_i;
    clic_irq_priv_i_cmp     <= clic_irq_priv_i;
    clic_irq_shv_i_cmp      <= clic_irq_shv_i;
    fencei_flush_ack_i_cmp  <= fencei_flush_ack_i;
    debug_req_i_cmp         <= debug_req_i;
    fetch_enable_i_cmp      <= fetch_enable_i;
 
    // Registers for holding output data from main core 
    instr_req_o_reg         <= instr_req_o;
    instr_addr_o_reg        <= instr_addr_o;
    instr_memtype_o_reg     <= instr_memtype_o;
    instr_prot_o_reg        <= instr_prot_o;
    instr_dbg_o_reg         <= instr_dbg_o;
    instr_reqpar_o_reg      <= instr_reqpar_o;
    instr_achk_o_reg        <= instr_achk_o;
    data_req_o_reg          <= data_req_o;
    data_addr_o_reg         <= data_addr_o;
    data_be_o_reg           <= data_be_o;
    data_we_o_reg           <= data_we_o;
    data_wdata_o_reg        <= data_wdata_o;
    data_memtype_o_reg      <= data_memtype_o;
    data_prot_o_reg         <= data_prot_o;
    data_dbg_o_reg          <= data_dbg_o;
    data_reqpar_o_reg       <= data_reqpar_o;
    data_achk_o_reg         <= data_achk_o;
    mcycle_o_reg            <= mcycle_o;
    fencei_flush_req_o_reg  <= fencei_flush_req_o;
    alert_minor_o_reg       <= alert_minor_o;
    alert_major_o_reg       <= alert_major_o;
    debug_havereset_o_reg   <= debug_havereset_o;
    debug_running_o_reg     <= debug_running_o;
    debug_halted_o_reg      <= debug_halted_o;
    debug_pc_valid_o_reg    <= debug_pc_valid_o;
    debug_pc_o_reg          <= debug_pc_o;
    core_sleep_o_reg        <= core_sleep_o;
    if_id_compare_o_reg     <= if_id_compare_o;
    id_ex_compare_o_reg     <= id_ex_compare_o;
    ex_wb_compare_o_reg     <= ex_wb_compare_o;
  end 
end

always_comb begin
    alert_compare_o[0] = 
    // Instruction memory interface
    (instr_req_o_reg != instr_req_o_cmp) |
    (instr_addr_o_reg != instr_addr_o_cmp) |
    (instr_memtype_o_reg != instr_memtype_o_cmp) |
    (instr_prot_o_reg != instr_prot_o_cmp) |
    (instr_dbg_o_reg != instr_dbg_o_cmp) |
    (instr_reqpar_o_reg != instr_reqpar_o_cmp) |
    (instr_achk_o_reg != instr_achk_o_cmp) |
    // Data memory interface
    (data_req_o_reg != data_req_o_cmp) |
    (data_addr_o_reg != data_addr_o_cmp) |
    (data_be_o_reg != data_be_o_cmp) |
    (data_we_o_reg != data_we_o_cmp) |
    (data_wdata_o_reg != data_wdata_o_cmp) |
    (data_memtype_o_reg != data_memtype_o_cmp) |
    (data_prot_o_reg != data_prot_o_cmp) |
    (data_dbg_o_reg != data_dbg_o_cmp) |
    (data_reqpar_o_reg != data_reqpar_o_cmp) |
    (data_achk_o_reg != data_achk_o_cmp) |
    // Cycle count
    (mcycle_o_reg != mcycle_o_cmp) |
    // Fence.i flush handshake
    (fencei_flush_req_o_reg != fencei_flush_req_o_cmp) |
    // Security Alerts
    (alert_minor_o_reg != alert_minor_o_cmp) |
    (alert_major_o_reg != alert_major_o_cmp) |
    // Debug interface
    (debug_havereset_o_reg != debug_havereset_o_cmp) |
    (debug_running_o_reg != debug_running_o_cmp) |
    (debug_halted_o_reg != debug_halted_o_cmp) |
    (debug_pc_valid_o_reg != debug_pc_valid_o_cmp) |
    (debug_pc_o_reg != debug_pc_o_cmp) |
    // CPU control signals
    (core_sleep_o_reg != core_sleep_o_cmp);
    // Comparison outputs
    
    alert_compare_o[1] = (if_id_compare_o_reg != if_id_compare_o_cmp);
    alert_compare_o[2] = (id_ex_compare_o_reg != id_ex_compare_o_cmp);
    alert_compare_o[3] = (ex_wb_compare_o_reg != ex_wb_compare_o_cmp);
end

cv32e40s_core
        #(
          .LIB                   ( LIB                   ),
          .RV32                  ( RV32                  ),
          .B_EXT                 ( B_EXT                 ),
          .M_EXT                 ( M_EXT                 ),
          .PMP_GRANULARITY       ( PMP_GRANULARITY       ),
          .PMP_NUM_REGIONS       ( PMP_NUM_REGIONS       ),
          .PMP_PMPNCFG_RV        ( PMP_PMPNCFG_RV        ),
          .PMP_PMPADDR_RV        ( PMP_PMPADDR_RV        ),
          .PMP_MSECCFG_RV        ( PMP_MSECCFG_RV        ),
          .CLIC                  ( CLIC                  ),
          .CLIC_ID_WIDTH         ( CLIC_ID_WIDTH         ),
          .DEBUG                 ( DEBUG                 ),
          .DM_REGION_START       ( DM_REGION_START       ),
          .DM_REGION_END         ( DM_REGION_END         ),
          .DBG_NUM_TRIGGERS      ( DBG_NUM_TRIGGERS      ),
          .PMA_NUM_REGIONS       ( PMA_NUM_REGIONS       ),
          .PMA_CFG               ( PMA_CFG               ),
          .LFSR0_CFG             ( LFSR0_CFG             ),
          .LFSR1_CFG             ( LFSR1_CFG             ),
          .LFSR2_CFG             ( LFSR2_CFG             ))
    core_cmp_i (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .scan_cg_en_i(scan_cg_en_i),

    // Static configuration
    .boot_addr_i(boot_addr_i_cmp),
    .dm_exception_addr_i(dm_exception_addr_i_cmp),
    .dm_halt_addr_i(dm_halt_addr_i_cmp),
    .mhartid_i(mhartid_i_cmp),
    .mimpid_patch_i(mimpid_patch_i_cmp),
    .mtvec_addr_i(mtvec_addr_i_cmp),

    // Instruction memory interface
    .instr_req_o(instr_req_o_cmp),
    .instr_gnt_i(instr_gnt_i_cmp),
    .instr_rvalid_i(instr_rvalid_i_cmp),
    .instr_addr_o(instr_addr_o_cmp),
    .instr_memtype_o(instr_memtype_o_cmp),
    .instr_prot_o(instr_prot_o_cmp),
    .instr_dbg_o(instr_dbg_o_cmp),
    .instr_rdata_i(instr_rdata_i_cmp),
    .instr_err_i(instr_err_i_cmp),
    .instr_reqpar_o(instr_reqpar_o_cmp),         // secure
    .instr_gntpar_i(instr_gntpar_i_cmp),         // secure
    .instr_rvalidpar_i(instr_rvalidpar_i_cmp),      // secure
    .instr_achk_o(instr_achk_o_cmp),           // secure
    .instr_rchk_i(instr_rchk_i_cmp),           // secure

    // Data memory interface
    .data_req_o(data_req_o_cmp),
    .data_gnt_i(data_gnt_i_cmp),
    .data_rvalid_i(data_rvalid_i_cmp),
    .data_addr_o(data_addr_o_cmp),
    .data_be_o(data_be_o_cmp),
    .data_we_o(data_we_o_cmp),
    .data_wdata_o(data_wdata_o_cmp),
    .data_memtype_o(data_memtype_o_cmp),
    .data_prot_o(data_prot_o_cmp),
    .data_dbg_o(data_dbg_o_cmp),
    .data_rdata_i(data_rdata_i_cmp),
    .data_err_i(data_err_i_cmp),
    .data_reqpar_o(data_reqpar_o_cmp),          // secure
    .data_gntpar_i(data_gntpar_i_cmp),          // secure
    .data_rvalidpar_i(data_rvalidpar_i_cmp),       // secure
    .data_achk_o(data_achk_o_cmp),            // secure
    .data_rchk_i(data_rchk_i_cmp),            // secure

    // Cycle count
    .mcycle_o(mcycle_o_cmp),

    // Basic interrupt architecture
    .irq_i(irq_i_cmp),

    // Event wakeup signals
    .wu_wfe_i(wu_wfe_i_cmp),   // Wait-for-event wakeup

    // CLIC interrupt architecture
    .clic_irq_i(clic_irq_i_cmp),
    .clic_irq_id_i(clic_irq_id_i_cmp),
    .clic_irq_level_i(clic_irq_level_i_cmp),
    .clic_irq_priv_i(clic_irq_priv_i_cmp),
    .clic_irq_shv_i(clic_irq_shv_i_cmp),

    // Fence.i flush handshake
    .fencei_flush_req_o(fencei_flush_req_o_cmp),
    .fencei_flush_ack_i(fencei_flush_ack_i_cmp),

    // Security Alerts
    .alert_minor_o(alert_minor_o_cmp),          // secure
    .alert_major_o(alert_major_o_cmp),          // secure

    // Debug interface
    .debug_req_i(debug_req_i_cmp),
    .debug_havereset_o(debug_havereset_o_cmp),
    .debug_running_o(debug_running_o_cmp),
    .debug_halted_o(debug_halted_o_cmp),
    .debug_pc_valid_o(debug_pc_valid_o_cmp),
    .debug_pc_o(debug_pc_o_cmp),

    // CPU control signals
    .fetch_enable_i(fetch_enable_i_cmp),
    .core_sleep_o(core_sleep_o_cmp),

    // Comparison outputs
    .if_id_compare_o(if_id_compare_o_cmp),
    .id_ex_compare_o(id_ex_compare_o_cmp),
    .ex_wb_compare_o(ex_wb_compare_o_cmp)
  );

\end{lstlisting}

\begin{lstlisting}[caption={TCL script for synthesizing designs and generating reports.}, label=lst:tcl, language=tcl]

source "../tcl/settings.tcl"

set TIMING_CLOCK_PORT "clk"

# Setup design libraries
set_db / .library $\$$LIB_FILES
set_db / .lef_library $\$$LEF_FILES
set_db / .qrc_tech_file $\$$QRC_FILES

set_db / .design_process_node 45

set_db auto_ungroup both

# Read source files
read_hdl -sv ../src/include/cv32e40s_pkg.sv

foreach sv_file [glob -nocomplain ../src/*.sv] {
	read_hdl -sv $\$$ sv_file
}

# Elaborate
elaborate $\$$DESIGN_TOP_MODULE

# Setup timing

read_sdc ../constraints/cv32e40s_core.sdc

set_load $\$$LOAD [all_outputs]

# Synthesis
syn_generic

syn_map

syn_opt
syn_opt -incremental

write_hdl > ../out/$\$${DESIGN_NAME}_synth.sv
write_sdf -delimiter / -edges check_edge -no_escape -setuphold split -recrem split > $\$$DESIGN_NAME.sdf.gz
write_spef -power > $\$$DESIGN_NAME.spef
write_sdc > ../out/$\$$DESIGN_NAME.sdc.gz
write_design -innovus -base_name session/$DESIGN_NAME

report_timing > reports/timing.txt
report_gates > reports/gates.txt
report_area > reports/area.txt
report_dp > reports/datapath.txt
report_power > reports/power.txt
report_sequential > reports/sequential.txt
report_clock_gating > reports/clock_gating.txt

#quit
\end{lstlisting}

\begin{lstlisting}[caption={Power usage report from synthesis of the CV32E40S.}, label=lst:cv32e40s_power, language=txt]

Instance: /cv32e40s_core
Power Unit: W
PDB Frames: /stim#0/frame#0
  -------------------------------------------------------------------------
    Category         Leakage     Internal    Switching        Total    Row%
  -------------------------------------------------------------------------
      memory     0.00000e+00  0.00000e+00  0.00000e+00  0.00000e+00   0.00%
    register     1.24472e-06  3.38053e-04  1.15429e-04  4.54727e-04  40.24%
       latch     0.00000e+00  0.00000e+00  0.00000e+00  0.00000e+00   0.00%
       logic     1.33087e-06  1.70770e-04  5.02775e-04  6.74876e-04  59.72%
        bbox     0.00000e+00  0.00000e+00  2.49260e-07  2.49260e-07   0.02%
       clock     0.00000e+00  0.00000e+00  2.17800e-07  2.17800e-07   0.02%
         pad     0.00000e+00  0.00000e+00  0.00000e+00  0.00000e+00   0.00%
          pm     0.00000e+00  0.00000e+00  0.00000e+00  0.00000e+00   0.00%
  -------------------------------------------------------------------------
    Subtotal     2.57559e-06  5.08823e-04  6.18671e-04  1.13007e-03 100.00%
  Percentage           0.23%       45.03%       54.75%      100.00% 100.00%
  -------------------------------------------------------------------------
\end{lstlisting}

\begin{lstlisting}[caption={Power usage report from synthesis of the CV32E40SDC.}, label=lst:cv32e40dc_power, language=txt]

Instance: /cv32e40s_dual_core
Power Unit: W
PDB Frames: /stim#0/frame#0
  -------------------------------------------------------------------------
    Category         Leakage     Internal    Switching        Total    Row%
  -------------------------------------------------------------------------
      memory     0.00000e+00  0.00000e+00  0.00000e+00  0.00000e+00   0.00%
    register     3.08383e-06  1.62940e-03  4.85935e-04  2.11842e-03  64.79%
       latch     0.00000e+00  0.00000e+00  0.00000e+00  0.00000e+00   0.00%
       logic     2.82440e-06  3.37798e-04  8.10212e-04  1.15083e-03  35.20%
        bbox     0.00000e+00  0.00000e+00  4.76740e-07  4.76740e-07   0.01%
       clock     0.00000e+00  0.00000e+00  0.00000e+00  0.00000e+00   0.00%
         pad     0.00000e+00  0.00000e+00  0.00000e+00  0.00000e+00   0.00%
          pm     0.00000e+00  0.00000e+00  0.00000e+00  0.00000e+00   0.00%
  -------------------------------------------------------------------------
    Subtotal     5.90822e-06  1.96720e-03  1.29662e-03  3.26973e-03 100.00%
  Percentage           0.18%       60.16%       39.66%      100.00% 100.00%
  -------------------------------------------------------------------------
\end{lstlisting}

\begin{lstlisting}[caption={Area report from synthesis of the CV32E40S.}, label=lst:cv32e40s_area, language=txt]

============================================================
  Generated by:           Genus(TM) Synthesis Solution 21.18-s082_1
  Generated on:           Dec 06 2023  02:01:52 pm
  Module:                 cv32e40s_core
  Operating conditions:   PVT_1P1V_0C 
  Interconnect mode:      global
  Area mode:              physical library
============================================================

                   Instance                                         Module                        Cell Count  Cell Area  Net Area   Total Area 
-----------------------------------------------------------------------------------------------------------------------------------------------
cv32e40s_core                                                                                          13525  42548.220 20572.873    63121.093 
  cs_registers_i_basic_mode_csrs.mcause_csr_i cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_          29     43.776    39.057       82.833 
  cs_registers_i_basic_mode_csrs.mie_csr_i    cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_          44     69.084    60.059      129.143 
  cs_registers_i_basic_mode_csrs.mtvec_csr_i  cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE1_          62     96.102    84.367      180.469 
  cs_registers_i_gen_debug_csr.dcsr_csr_i     cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE10          24     35.568    33.868       69.436 
  cs_registers_i_jvt_csr_i                    cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_          62     96.102    84.367      180.469 
  cs_registers_i_mepc_csr_i                   cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_          72    113.886    98.736      212.622 
  cs_registers_i_mscratch_csr_i               cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_          75    116.964   102.062      219.026 
  cs_registers_i_mstateen0_csr_i              cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_           2      3.078     2.585        5.663 
  cs_registers_i_mstatus_csr_i                cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE61          14     22.572    19.519       42.091 
  cs_registers_i_privlvl_user.priv_lvl_i      cv32e40s_csr_LIB0_WIDTH2_SHADOWCOPY1_RESETVALUE3_M           5      7.524     6.272       13.796 
  cs_registers_i_xsecure.cpuctrl_csr_i        cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE25          21     32.832    28.376       61.208 
  sleep_unit_i                                cv32e40s_sleep_unit_LIB0                                     7     21.204     4.067       25.271 


\end{lstlisting}

\begin{lstlisting}[caption={Area report from synthesis of the CV32E40SDC.}, label=lst:cv32e40dc_area, language=txt]

============================================================
  Generated by:           Genus(TM) Synthesis Solution 21.18-s082_1
  Generated on:           Dec 15 2023  06:57:43 pm
  Module:                 cv32e40s_dual_core
  Operating conditions:   PVT_1P1V_0C 
  Interconnect mode:      global
  Area mode:              physical library
============================================================

                           Instance                                                  Module                        Cell Count  Cell Area  Net Area   Total Area 
----------------------------------------------------------------------------------------------------------------------------------------------------------------
cv32e40s_dual_core                                                                                                      29351  97142.022 43445.210   140587.232 
  core_cmp_i_cs_registers_i_basic_mode_csrs.mcause_csr_i       cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_          29     43.776    39.057       82.833 
  core_cmp_i_cs_registers_i_basic_mode_csrs.mie_csr_i          cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_          44     69.084    60.059      129.143 
  core_cmp_i_cs_registers_i_basic_mode_csrs.mtvec_csr_i        cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE1_          62     96.102    84.367      180.469 
  core_cmp_i_cs_registers_i_gen_debug_csr.dcsr_csr_i           cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE10          24     35.568    33.868       69.436 
  core_cmp_i_cs_registers_i_jvt_csr_i                          cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_          62     96.102    84.367      180.469 
  core_cmp_i_cs_registers_i_mepc_csr_i                         cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_          72    113.886    98.736      212.622 
  core_cmp_i_cs_registers_i_mscratch_csr_i                     cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_          75    116.964   102.062      219.026 
  core_cmp_i_cs_registers_i_mstateen0_csr_i                    cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_           2      3.078     2.585        5.663 
  core_cmp_i_cs_registers_i_mstatus_csr_i                      cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE61          14     22.572    19.519       42.091 
  core_cmp_i_cs_registers_i_privlvl_user.priv_lvl_i            cv32e40s_csr_LIB0_WIDTH2_SHADOWCOPY1_RESETVALUE3_M           5      7.524     6.272       13.796 
  core_cmp_i_cs_registers_i_xsecure.cpuctrl_csr_i              cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE25          21     32.832    28.376       61.208 
  core_cmp_i_ex_stage_i_alu_i_ff_one_i                         cv32e40s_ff_one                                             52     85.158    50.347      135.505 
  core_cmp_i_gen_basic_interrupt.int_controller_i              cv32e40s_int_controller                                     79    211.698    53.007      264.705 
  core_cmp_i_id_stage_i_decoder_i_i_decoder_i                  cv32e40s_i_decoder_CLIC0                                   168    251.370   159.896      411.266 
  core_cmp_i_if_stage_i_gen_dummy_instr.dummy_instr_i          cv32e40s_dummy_instr                                        56    126.882    59.469      186.351 
  core_cmp_i_register_file_wrapper_i_genblk2.register_file_ecc cv32e40s_register_file_ecc_REGFILE_NUM_READ_PORTS2         190    462.384   150.451      612.835 
  core_cmp_i_sleep_unit_i                                      cv32e40s_sleep_unit_LIB0                                     6     19.152     3.326       22.478 
  cs_registers_i_basic_mode_csrs.mcause_csr_i                  cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_          29     43.776    39.057       82.833 
  cs_registers_i_basic_mode_csrs.mie_csr_i                     cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_          44     69.084    60.059      129.143 
  cs_registers_i_basic_mode_csrs.mtvec_csr_i                   cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE1_          62     96.102    84.367      180.469 
  cs_registers_i_gen_debug_csr.dcsr_csr_i                      cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE10          24     35.568    33.868       69.436 
  cs_registers_i_jvt_csr_i                                     cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_          62     96.102    84.367      180.469 
  cs_registers_i_mepc_csr_i                                    cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_          72    113.886    98.736      212.622 
  cs_registers_i_mscratch_csr_i                                cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_          75    116.964   102.062      219.026 
  cs_registers_i_mstateen0_csr_i                               cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE0_           2      3.078     2.585        5.663 
  cs_registers_i_mstatus_csr_i                                 cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE61          14     22.572    19.519       42.091 
  cs_registers_i_privlvl_user.priv_lvl_i                       cv32e40s_csr_LIB0_WIDTH2_SHADOWCOPY1_RESETVALUE3_M           5      7.524     6.272       13.796 
  cs_registers_i_xsecure.cpuctrl_csr_i                         cv32e40s_csr_LIB0_WIDTH32_SHADOWCOPY1_RESETVALUE25          21     32.832    28.376       61.208 
  ex_stage_i_alu_i_ff_one_i                                    cv32e40s_ff_one_6850                                        52     85.158    50.347      135.505 
  id_stage_i_decoder_i_i_decoder_i                             cv32e40s_i_decoder_CLIC0_3572                              167    252.054   158.433      410.487 
  if_stage_i_gen_dummy_instr.dummy_instr_i                     cv32e40s_dummy_instr_3569                                   56    126.882    59.469      186.351 
  register_file_wrapper_i_genblk2.register_file_ecc            cv32e40s_register_file_ecc_REGFILE_NUM_READ_PORTS2         190    462.384   150.451      612.835 
  sleep_unit_i                                                 cv32e40s_sleep_unit_LIB0_6852                                7     21.204     4.067       25.271 


\end{lstlisting}

