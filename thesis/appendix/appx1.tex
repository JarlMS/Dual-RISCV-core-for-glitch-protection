\chapter{Appendix 1 - Code}
\label{app:appx1}

Any source code referenced in the project is shown in this appendix.

\section{Sanity test for the CV32E40S core}
\label{app:helloworldC}

\lstset{ 
   language=C,                   % choose the language of the code
   breaklines=true,                % sets automatic line breaking
   breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
}
\begin{lstlisting}[caption={Sanity test for the CV32E40S core.}, label=lst:sample_code]
    /*
**
** Copyright 2020 OpenHW Group
**
** Licensed under the Solderpad Hardware Licence, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     https://solderpad.org/licenses/
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
*******************************************************************************
**
** Sanity test for the CV32E40S core.  Reads the MVENDORID, MISA, MARCHID and
**                                     MIMPID CSRs and prints some useful (?)
**                                     messages to stdout.  Will fail if these
**                                     CSRs do not match expected values.
**
*******************************************************************************
*/

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

#define EXP_MISA 0x40901104

int main(int argc, char *argv[])
{

    volatile unsigned int misa_rval, mvendorid_rval, marchid_rval, mimpid_rval, mxl;
    volatile          int reserved, tentative, nonstd, user, super;

    mxl = 0; reserved = 0; tentative = 0; nonstd = 0; user = 0; super = 0;

    /* inline assembly: read mvendorid and misa */
    __asm__ volatile("csrr %0, 0xF11" : "=r"(mvendorid_rval));
    __asm__ volatile("csrr %0, 0x301" : "=r"(misa_rval));
    __asm__ volatile("csrr %0, 0xF12" : "=r"(marchid_rval));
    __asm__ volatile("csrr %0, 0xF13" : "=r"(mimpid_rval));

    /* Check MVENDORID CSR: 0x602 is the value assigned by JEDEC to the OpenHW Group */
    if (mvendorid_rval != 0x00000602) {
      printf("\tERROR: CSR MVENDORID reads as 0x%x - should be 0x00000602 for the OpenHW Group.\n\n", mvendorid_rval);
      return EXIT_FAILURE;
    }

    /* Check MISA CSR: if its zero, it might not be implemented at all */
    if (misa_rval != EXP_MISA) {
      printf("\tERROR: CSR MISA reads as 0x%x - should be 0x%x for this release of CV32E40S!\n\n", misa_rval, EXP_MISA);
      return EXIT_FAILURE;
    }

    /* Check MARCHID CSR: 0x15 is the value assigned by the RISC-V Foundation to CV32E40S */
    if (marchid_rval != 0x15) {
      printf("\tERROR: CSR MARCHID reads as 0x%x - should be 0x00000015 for CV32E40S.\n\n", marchid_rval);
      return EXIT_FAILURE;
    }

    /* Check MIMPID CSR: 0x0 is the value assigned by the OpenHW Group to the first release of CV32E40S */
    if (mimpid_rval != 0x00000000) {
      printf("\tERROR: CSR MIMPID reads as 0x%x - should be 0x00000000 for this release of CV32E40S.\n\n", mimpid_rval);
      return EXIT_FAILURE;
    }

    /* Print a banner to stdout and interpret MISA CSR */
    printf("\nHELLO WORLD!!!\n");
    printf("This is the OpenHW Group CV32E40S CORE-V processor core.\n");
    printf("CV32E40S is a RISC-V ISA compliant core with the following attributes:\n");
    printf("\tmvendorid = 0x%x\n", mvendorid_rval);
    printf("\tmarchid   = 0x%x\n", marchid_rval);
    printf("\tmimpid    = 0x%x\n", mimpid_rval);
    printf("\tmisa      = 0x%x\n", misa_rval);
    mxl = ((misa_rval & 0xC0000000) >> 30); // MXL == MISA[31:30]
    switch (mxl) {
      case 0:  printf("\tERROR: MXL cannot be zero!\n");
               return EXIT_FAILURE;
               break;
      case 1:  printf("\tXLEN is 32-bits\n");
               break;
      case 2:  printf("\tXLEN is 64-bits\n");
               break;
      case 3:  printf("\tXLEN is 128-bits\n");
               break;
      default: printf("\tERROR: mxl (%0d) not in 0..3, your code is broken!\n", mxl);
               return EXIT_FAILURE;
    }

    printf("\tSupported Instructions Extensions: ");
    if ((misa_rval >> 25) & 0x00000001) ++reserved;
    if ((misa_rval >> 24) & 0x00000001) ++reserved;
    if ((misa_rval >> 23) & 0x00000001) {
      printf("X");
      ++nonstd;
    }
    if ((misa_rval >> 22) & 0x00000001) ++reserved;
    if ((misa_rval >> 21) & 0x00000001) ++tentative;
    if ((misa_rval >> 20) & 0x00000001) ++user;
    if ((misa_rval >> 19) & 0x00000001) ++tentative;
    if ((misa_rval >> 18) & 0x00000001) ++super;
    if ((misa_rval >> 17) & 0x00000001) ++reserved;
    if ((misa_rval >> 16) & 0x00000001) printf("Q");
    if ((misa_rval >> 15) & 0x00000001) ++tentative;
    if ((misa_rval >> 14) & 0x00000001) ++reserved;
    if ((misa_rval >> 13) & 0x00000001) printf("N");
    if ((misa_rval >> 12) & 0x00000001) printf("M");
    if ((misa_rval >> 11) & 0x00000001) ++tentative;
    if ((misa_rval >> 10) & 0x00000001) ++reserved;
    if ((misa_rval >>  9) & 0x00000001) printf("J");
    if ((misa_rval >>  8) & 0x00000001) printf("I");
    if ((misa_rval >>  7) & 0x00000001) printf("H");
    if ((misa_rval >>  6) & 0x00000001) printf("G");
    if ((misa_rval >>  5) & 0x00000001) printf("F");
    if ((misa_rval >>  4) & 0x00000001) printf("E");
    if ((misa_rval >>  3) & 0x00000001) printf("D");
    if ((misa_rval >>  2) & 0x00000001) printf("C");
    if ((misa_rval >>  1) & 0x00000001) printf("B");
    if ((misa_rval      ) & 0x00000001) printf("A");
    printf("\n");
    if (super) {
      printf("\tThis machine supports SUPERVISOR mode.\n");
    }
    if (user) {
      printf("\tThis machine supports USER mode.\n");
    }
    if (nonstd) {
      printf("\tThis machine supports non-standard instructions.\n");
    }
    if (tentative) {
      printf("\tWARNING: %0d tentative instruction extensions are defined!\n", tentative);
    }
    if (reserved) {
      printf("\tERROR: %0d reserved instruction extensions are defined!\n\n", reserved);
      return EXIT_FAILURE;
    }
    else {
      printf("\n");
      return EXIT_SUCCESS;
    }
}

\end{lstlisting}

% Define RISC-V Assembly language style
\lstdefinelanguage{riscv}{
  morekeywords={add,sub,li,lw,sw,nop,push,addi4spn,jal,beqz,addi,bgeu,j,mv,popret}, % Add your RISC-V instructions
  sensitive=false,
  morecomment=[l]{\#},
  morestring=[b]",
}


\begin{lstlisting}[caption={Assembly code for instruction skip test program}, label=lst:asm_instr_skip, language=riscv]
00000438 <main>:

int main(int argc, char *argv[])
{
     438:	b85a                    cm.push {x1,x8},-48
     43a:	1800                    c.addi4spn	x8,x2,48
     43c:	fca42e23                sw	x10,-36(x8)
     440:	fcb42c23                sw	x11,-40(x8)
    /* Print a banner to stdout */
    // printf("\nHello World! This is the new glitch test\n");
    int result_code = 0;
     444:	fe042423                sw	x0,-24(x8)

    /* Count to avoid actual infite loop */
    unsigned int count = 0;
     448:	fe042623                sw	x0,-20(x8)

    /* Get error result code */
    result_code = boot_go();
     44c:	37f1                    c.jal   418 <boot_go>
     44e:	fea42423                sw	x10,-24(x8)

    if (result_code != 0) {
     452:	fe842783                lw	x15,-24(x8)
     456:	c395                    c.beqz  x15,47a <main+0x42>
      // printf("Unable to find bootable image\n");
      while(1) {
        count++;
     458:	fec42783                lw	x15,-20(x8)
     45c:	0785                    c.addi  x15,1
     45e:	fef42623                sw	x15,-20(x8)
        if (count > 10) {
     462:	fec42703                lw	x14,-20(x8)
     466:	47a9                    c.li    x15,10
     468:	fee7f8e3                bgeu    x15,x14,458 <main+0x20>
          printf("Exiting...\n");
     46c:	6791                    c.lui   x15,0x4
     46e:	84c78513                addi    x10,x15,-1972 # 384c <nmi_end_handler_ret+0x28>
     472:	05b000ef                jal     x1,ccc <puts>
          return EXIT_SUCCESS;
     476:	4781                    c.li    x15,0
     478:	a801                    c.j     488 <main+0x50>
        }
      }
    }

    printf("Glitched out of loop\n");
     47a:	6791                    c.lui   x15,0x4
     47c:	85878513                addi    x10,x15,-1960 # 3858 <nmi_end_handler_ret+0x34>
     480:	04d000ef                jal     x1,ccc <puts>
    do_boot();
     484:	3755                    c.jal   428 <do_boot>
    return EXIT_FAILURE;
     486:	4785                    c.li    x15,1
}
     488:	853e                    c.mv    x10,x15
     48a:	be5a                    cm.popret	{x1,x8},48

\end{lstlisting}

\begin{lstlisting}[caption={Assembly code for coverage test program}, label=lst:asm_coverage, language=riscv]

00000418 <main>:
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
     418:	b85a                    cm.push {x1,x8},-48
     41a:       1800                    c.addi4spn	x8,x2,48
     41c:	fca42e23                sw      x10,-36(x8)
     420:	fcb42c23                sw      x11,-40(x8)
    int prev = 0;
     424:       fe042623                sw	x0,-20(x8)
    int current = 1;
     428:	4785                    c.li    x15,1
     42a:	fef42423                sw      x15,-24(x8)

    for (int i = 1; i < 20; i++) {
     42e:       4785                    c.li    x15,1
     430:       fef42223                sw	x15,-28(x8)
     434:       a02d                    c.j     45e <main+0x46>
        int next = prev + current;
     436:	fec42703                lw	x14,-20(x8)
     43a:	fe842783                lw	x15,-24(x8)
     43e:	97ba                    c.add   x15,x14
     440:	fef42023                sw	x15,-32(x8)
        prev = current;
     444:	fe842783                lw	x15,-24(x8)
     448:	fef42623                sw	x15,-20(x8)
        current = next;
     44c:	fe042783                lw	x15,-32(x8)
     450:	fef42423                sw	x15,-24(x8)
    for (int i = 1; i < 20; i++) {
     454:	fe442783                lw	x15,-28(x8)
     458:	0785                    c.addi  x15,1
     45a:	fef42223                sw	x15,-28(x8)
     45e:	fe442703                lw	x14,-28(x8)
     462:	47cd                    c.li    x15,19
     464:	fce7d9e3                bge     x15,x14,436 <main+0x1e>
    }

    if (current == 6765) {
     468:	fe842703                lw	x14,-24(x8)
     46c:	6789                    c.lui   x15,0x2
     46e:	a6d78793                addi    x15,x15,-1427 # 1a6d <__sfvwrite_r+0x35d>
     472:	00f71963                bne     x14,x15,484 <main+0x6c>
        printf("No glitch detected\n");
     476:	6791                    c.lui   x15,0x4
     478:	85478513                addi    x10,x15,-1964 # 3854 <nmi_end_handler_ret+0x28>
     47c:	059000ef                jal     x1,cd4 <puts>
        return EXIT_SUCCESS;
     480:	4781                    c.li    x15,0
     482:	a039                    c.j     490 <main+0x78>
    }
    printf("Glitch detected\n");
     484:	6791                    c.lui   x15,0x4
     486:	86878513                addi    x10,x15,-1944 # 3868 <nmi_end_handler_ret+0x3c>
     48a:	04b000ef                jal     x1,cd4 <puts>
    return EXIT_FAILURE;
     48e:	4785                    c.li    x15,1
}
     490:	853e                    c.mv    x10,x15
     492:	be5a                    cm.popret	{x1,x8},48
\end{lstlisting}
