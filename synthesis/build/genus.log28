Cadence Genus(TM) Synthesis Solution.
Copyright 2023 Cadence Design Systems, Inc. All rights reserved worldwide.
Cadence and the Cadence logo are registered trademarks and Genus is a trademark
of Cadence Design Systems, Inc. in the United States and other countries.

[13:06:36.023451] Configured Lic search path (21.01-s002): 1700@europa.tele.ntnu.no:5280@europa.tele.ntnu.no:1717@europa.tele.ntnu.no

Version: 21.18-s082_1, built Tue Jul 18 04:08:41 PDT 2023
Options: -files ../tcl/synth.tcl 
Date:    Mon Oct 23 13:06:36 2023
Host:    jupiter.tele.ntnu.no (x86_64 w/Linux 3.10.0-1160.99.1.el7.x86_64) (4cores*16cpus*1physical cpu*Intel(R) Xeon(R) CPU X5560 @ 2.80GHz 8192KB) (24508716KB)
PID:     22960
OS:      CentOS Linux release 7.9.2009 (Core)


[13:06:36.225120] Periodic Lic check successful
[13:06:36.225137] Feature usage summary:
[13:06:36.225138] Genus_Synthesis
Checking out license: Genus_Synthesis


***********************************************************************************************************
***********************************************************************************************************



Loading tool scripts...
Finished loading tool scripts (27 seconds elapsed).

#@ Processing -files option
@genus 1> source ../tcl/synth.tcl
#@ Begin verbose source ../tcl/synth.tcl
@file(synth.tcl) 1: source "../tcl/settings.tcl"
Sourcing '../tcl/settings.tcl' (Mon Oct 23 13:07:03 CEST 2023)...
#@ Begin verbose source ../tcl/settings.tcl
@file(settings.tcl) 1: set DESIGN_NAME "cv32e40s"
@file(settings.tcl) 2: set DESIGN_TOP_MODULE "cv32e40s_core"
@file(settings.tcl) 5: set TIMING_CLOCK_PERIOD 5405
@file(settings.tcl) 6: set TIMING_INPUT_DELAY 0.2
@file(settings.tcl) 7: set TIMING_OUTPUT_DELAY 15
@file(settings.tcl) 8: set LOAD 0.1
@file(settings.tcl) 10: set PATH_LIB_BASE "/eda/kits/cadence/45nm/gsclib045_all_v4.4"
@file(settings.tcl) 11: set PATH_TECHNOKIT "$PATH_LIB_BASE/gsclib045_tech/"
@file(settings.tcl) 13: set LIB_FILES {}
@file(settings.tcl) 14: lappend LIB_FILES ${PATH_LIB_BASE}/gsclib045/timing/fast_vdd1v0_basicCells.lib
@file(settings.tcl) 15: lappend LIB_FILES ${PATH_LIB_BASE}/gsclib045/timing/fast_vdd1v0_extvdd1v0.lib
@file(settings.tcl) 16: lappend LIB_FILES ${PATH_LIB_BASE}/gsclib045/timing/fast_vdd1v0_extvdd1v2.lib
@file(settings.tcl) 17: lappend LIB_FILES ${PATH_LIB_BASE}/gsclib045/timing/fast_vdd1v0_multibitsDFF.lib
@file(settings.tcl) 18: lappend LIB_FILES ${PATH_LIB_BASE}/gsclib045/timing/fast_vdd1v2_basicCells.lib
@file(settings.tcl) 19: lappend LIB_FILES ${PATH_LIB_BASE}/gsclib045/timing/fast_vdd1v2_extvdd1v0.lib
@file(settings.tcl) 20: lappend LIB_FILES ${PATH_LIB_BASE}/gsclib045/timing/fast_vdd1v2_extvdd1v2.lib
@file(settings.tcl) 21: lappend LIB_FILES ${PATH_LIB_BASE}/gsclib045/timing/fast_vdd1v2_multibitsDFF.lib
@file(settings.tcl) 23: lappend LIB_FILES ${PATH_LIB_BASE}/gsclib045/timing/slow_vdd1v0_basicCells.lib
@file(settings.tcl) 24: lappend LIB_FILES ${PATH_LIB_BASE}/gsclib045/timing/slow_vdd1v0_extvdd1v0.lib
@file(settings.tcl) 25: lappend LIB_FILES ${PATH_LIB_BASE}/gsclib045/timing/slow_vdd1v0_extvdd1v2.lib
@file(settings.tcl) 26: lappend LIB_FILES ${PATH_LIB_BASE}/gsclib045/timing/slow_vdd1v0_multibitsDFF.lib
@file(settings.tcl) 27: lappend LIB_FILES ${PATH_LIB_BASE}/gsclib045/timing/slow_vdd1v2_basicCells.lib
@file(settings.tcl) 28: lappend LIB_FILES ${PATH_LIB_BASE}/gsclib045/timing/slow_vdd1v2_extvdd1v0.lib
@file(settings.tcl) 29: lappend LIB_FILES ${PATH_LIB_BASE}/gsclib045/timing/slow_vdd1v2_extvdd1v2.lib
@file(settings.tcl) 30: lappend LIB_FILES ${PATH_LIB_BASE}/gsclib045/timing/slow_vdd1v2_multibitsDFF.lib
@file(settings.tcl) 32: set slow_libs {}
@file(settings.tcl) 33: lappend slow_libs ${PATH_LIB_BASE}/gsclib045_lvt/timingfast_vdd1v0_basicCells_lvt.lib
@file(settings.tcl) 34: lappend slow_libs ${PATH_LIB_BASE}/gsclib045_lvt/timingfast_vdd1v2_basicCells_lvt.lib
@file(settings.tcl) 35: lappend slow_libs ${PATH_LIB_BASE}/gsclib045_lvt/timingslow_vdd1v0_basicCells_lvt.lib
@file(settings.tcl) 36: lappend slow_libs ${PATH_LIB_BASE}/gsclib045_lvt/timingslow_vdd1v2_basicCells_lvt.lib
@file(settings.tcl) 38: set fast_libs {}
@file(settings.tcl) 39: lappend fast_libs ${PATH_LIB_BASE}/gsclib045_hvt/timing/fast_vdd1v0_basicCells_hvt.lib
@file(settings.tcl) 40: lappend fast_libs ${PATH_LIB_BASE}/gsclib045_hvt/timing/fast_vdd1v2_basicCells_hvt.lib
@file(settings.tcl) 41: lappend fast_libs ${PATH_LIB_BASE}/gsclib045_hvt/timing/slow_vdd1v0_basicCells_hvt.lib
@file(settings.tcl) 42: lappend fast_libs ${PATH_LIB_BASE}/gsclib045_hvt/timing/slow_vdd1v2_basicCells_hvt.lib
@file(settings.tcl) 44: set LEF_FILES {}
@file(settings.tcl) 45: lappend LEF_FILES $PATH_TECHNOKIT/lef/gsclib045_tech.lef
@file(settings.tcl) 46: lappend LEF_FILES $PATH_LIB_BASE/gsclib045/lef/gsclib045_macro.lef
@file(settings.tcl) 47: lappend LEF_FILES $PATH_LIB_BASE/gsclib045/lef/gsclib045_multibitsDFF.lef
@file(settings.tcl) 48: lappend LEF_FILES $PATH_LIB_BASE/gsclib045/lef/gsclib045_tech.lef
@file(settings.tcl) 49: lappend LEF_FILES $PATH_LIB_BASE/gsclib045_backbias/lef/gsclib045_backbias_macro.lef
@file(settings.tcl) 50: lappend LEF_FILES $PATH_LIB_BASE/gsclib045_hvt/lef/gsclib045_hvt_macro.lef
@file(settings.tcl) 51: lappend LEF_FILES $PATH_LIB_BASE/gsclib045_lvt/lef/gsclib045_lvt_macro.lef
@file(settings.tcl) 53: set QRC_FILES {}
@file(settings.tcl) 54: lappend QRC_FILES $PATH_TECHNOKIT/qrc/qx/gpdk045.tch
#@ End verbose source ../tcl/settings.tcl
@file(synth.tcl) 3: set TIMING_CLOCK_PORT "clk"
@file(synth.tcl) 6: set_db / .library $LIB_FILES

Threads Configured:8

Reading library /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/fast_vdd1v0_multibitsDFF.lib
Reading library /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/fast_vdd1v2_multibitsDFF.lib
Reading library /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/slow_vdd1v0_multibitsDFF.lib
Reading library /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/slow_vdd1v2_multibitsDFF.lib
  Message Summary for Library all 16 libraries:
  *********************************************
  Missing a function attribute in the output pin definition. [LBR-518]: 196
  Appending library. [LBR-3]: 4
  *********************************************
 
Warning : Libraries have inconsistent nominal operating conditions. In the Liberty library, there are attributes called nom_voltage, nom_process and nom_temperature. Genus reports the message, if the respective values of the 2 given .libs differ. [LBR-38]
        : The libraries are 'fast_vdd1v0' and 'fast_vdd1v2'.
        : This is a common source of delay calculation confusion and should be avoided.
Warning : Libraries have inconsistent nominal operating conditions. In the Liberty library, there are attributes called nom_voltage, nom_process and nom_temperature. Genus reports the message, if the respective values of the 2 given .libs differ. [LBR-38]
        : The libraries are 'fast_vdd1v0' and 'fast_vdd1v2_extvdd1v0'.
Warning : Libraries have inconsistent nominal operating conditions. In the Liberty library, there are attributes called nom_voltage, nom_process and nom_temperature. Genus reports the message, if the respective values of the 2 given .libs differ. [LBR-38]
        : The libraries are 'fast_vdd1v0' and 'fast_vdd1v2_extvdd1v2'.
Warning : Libraries have inconsistent nominal operating conditions. In the Liberty library, there are attributes called nom_voltage, nom_process and nom_temperature. Genus reports the message, if the respective values of the 2 given .libs differ. [LBR-38]
        : The libraries are 'fast_vdd1v0' and 'fast_vdd1v2'.
Warning : Libraries have inconsistent nominal operating conditions. In the Liberty library, there are attributes called nom_voltage, nom_process and nom_temperature. Genus reports the message, if the respective values of the 2 given .libs differ. [LBR-38]
        : The libraries are 'fast_vdd1v0' and 'slow_vdd1v0'.
Warning : Libraries have inconsistent nominal operating conditions. In the Liberty library, there are attributes called nom_voltage, nom_process and nom_temperature. Genus reports the message, if the respective values of the 2 given .libs differ. [LBR-38]
        : The libraries are 'fast_vdd1v0' and 'slow_vdd1v0_extvdd1v0'.
Warning : Libraries have inconsistent nominal operating conditions. In the Liberty library, there are attributes called nom_voltage, nom_process and nom_temperature. Genus reports the message, if the respective values of the 2 given .libs differ. [LBR-38]
        : The libraries are 'fast_vdd1v0' and 'slow_vdd1v0_extvdd1v2'.
Warning : Libraries have inconsistent nominal operating conditions. In the Liberty library, there are attributes called nom_voltage, nom_process and nom_temperature. Genus reports the message, if the respective values of the 2 given .libs differ. [LBR-38]
        : The libraries are 'fast_vdd1v0' and 'slow_vdd1v0'.
Warning : Libraries have inconsistent nominal operating conditions. In the Liberty library, there are attributes called nom_voltage, nom_process and nom_temperature. Genus reports the message, if the respective values of the 2 given .libs differ. [LBR-38]
        : The libraries are 'fast_vdd1v0' and 'slow_vdd1v2'.
Warning : Libraries have inconsistent nominal operating conditions. In the Liberty library, there are attributes called nom_voltage, nom_process and nom_temperature. Genus reports the message, if the respective values of the 2 given .libs differ. [LBR-38]
        : The libraries are 'fast_vdd1v0' and 'slow_vdd1v2_extvdd1v0'.
Warning : Libraries have inconsistent nominal operating conditions. In the Liberty library, there are attributes called nom_voltage, nom_process and nom_temperature. Genus reports the message, if the respective values of the 2 given .libs differ. [LBR-38]
        : The libraries are 'fast_vdd1v0' and 'slow_vdd1v2_extvdd1v2'.
Warning : Libraries have inconsistent nominal operating conditions. In the Liberty library, there are attributes called nom_voltage, nom_process and nom_temperature. Genus reports the message, if the respective values of the 2 given .libs differ. [LBR-38]
        : The libraries are 'fast_vdd1v0' and 'slow_vdd1v2'.
Info    : Created nominal operating condition. [LBR-412]
        : Operating condition '_nominal_' was created for the PVT values (1.000000, 1.100000, 0.000000) in library 'fast_vdd1v0_multibitsDFF.lib'.
        : The nominal operating condition is represented, either by the nominal PVT values specified in the library source (via nom_process,nom_voltage and nom_temperature respectively), or by the default PVT values (1.0,1.0,1.0).
Warning : Ignoring unsupported lu_table_template. [LBR-403]
        : Ignoring lu_table_template index type (input_voltage).
        : LBR-403 is issued when an unsupported lu_table_template is encountered by GENUS.
Info    : Created nominal operating condition. [LBR-412]
        : Operating condition '_nominal_' was created for the PVT values (1.000000, 1.100000, 0.000000) in library 'fast_vdd1v0_extvdd1v0.lib'.
Info    : Created nominal operating condition. [LBR-412]
        : Operating condition '_nominal_' was created for the PVT values (1.000000, 1.100000, 0.000000) in library 'fast_vdd1v0_extvdd1v2.lib'.
Info    : Created nominal operating condition. [LBR-412]
        : Operating condition '_nominal_' was created for the PVT values (1.000000, 1.320000, 0.000000) in library 'fast_vdd1v2_multibitsDFF.lib'.
Info    : Created nominal operating condition. [LBR-412]
        : Operating condition '_nominal_' was created for the PVT values (1.000000, 1.320000, 0.000000) in library 'fast_vdd1v2_extvdd1v0.lib'.
Warning : Ignoring unsupported lu_table_template. [LBR-403]
        : Ignoring lu_table_template index type (input_voltage).
Info    : Created nominal operating condition. [LBR-412]
        : Operating condition '_nominal_' was created for the PVT values (1.000000, 1.320000, 0.000000) in library 'fast_vdd1v2_extvdd1v2.lib'.
Info    : Created nominal operating condition. [LBR-412]
        : Operating condition '_nominal_' was created for the PVT values (1.000000, 0.900000, 125.000000) in library 'slow_vdd1v0_multibitsDFF.lib'.
Warning : Ignoring unsupported lu_table_template. [LBR-403]
        : Ignoring lu_table_template index type (input_voltage).
Info    : Created nominal operating condition. [LBR-412]
        : Operating condition '_nominal_' was created for the PVT values (1.000000, 0.900000, 125.000000) in library 'slow_vdd1v0_extvdd1v0.lib'.
Info    : Created nominal operating condition. [LBR-412]
        : Operating condition '_nominal_' was created for the PVT values (1.000000, 0.900000, 125.000000) in library 'slow_vdd1v0_extvdd1v2.lib'.
Info    : Created nominal operating condition. [LBR-412]
        : Operating condition '_nominal_' was created for the PVT values (1.000000, 1.080000, 125.000000) in library 'slow_vdd1v2_multibitsDFF.lib'.
Info    : Created nominal operating condition. [LBR-412]
        : Operating condition '_nominal_' was created for the PVT values (1.000000, 1.080000, 125.000000) in library 'slow_vdd1v2_extvdd1v0.lib'.
Warning : Ignoring unsupported lu_table_template. [LBR-403]
        : Ignoring lu_table_template index type (input_voltage).
Info    : Created nominal operating condition. [LBR-412]
        : Operating condition '_nominal_' was created for the PVT values (1.000000, 1.080000, 125.000000) in library 'slow_vdd1v2_extvdd1v2.lib'.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'ANTENNA' must have an output pin.
        : Add the missing output pin(s), then reload the library. Else the library cell will be marked as timing model i.e. unusable. Timing_model means that the cell does not have any defined function. If there is no output pin, Genus will mark library cell as unusable i.e. the attribute 'usable' will be marked to 'false' on the libcell. Therefore, the cell is not used for mapping and it will not be picked up from the library for synthesis. If you query the attribute 'unusable_reason' on the libcell; result will be: 'Library cell has no output pins.'Note: The message LBR-9 is only for the logical pins and not for the power_ground pins. Genus will depend upon the output function defined in the pin group (output pin) of the cell, to use it for mapping. The pg_pin will not have any function defined.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'ANTENNA' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP10' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP10' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP2' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP2' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP3' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP3' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP4' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP4' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP5' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP5' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP6' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP6' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP7' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP7' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP8' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP8' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP9' must have an output pin.
Warning : Library cell has no output pins defined. [LBR-9]
        : Library cell 'DECAP9' must have an output pin.
Warning : Maximum message print count reached. [MESG-11]
        : Maximum print count of '20' reached for message 'LBR-9'.
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/ACHCONX2 and fast_vdd1v2/ACHCONX2).  Deleting (fast_vdd1v2/ACHCONX2).
        : Library cell names must be unique.  Any duplicates will be deleted.  Only the first (as determined by the order of libraries) will be retained.
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/ADDFHX1 and fast_vdd1v2/ADDFHX1).  Deleting (fast_vdd1v2/ADDFHX1).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/ADDFHX2 and fast_vdd1v2/ADDFHX2).  Deleting (fast_vdd1v2/ADDFHX2).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/ADDFHX4 and fast_vdd1v2/ADDFHX4).  Deleting (fast_vdd1v2/ADDFHX4).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/ADDFHXL and fast_vdd1v2/ADDFHXL).  Deleting (fast_vdd1v2/ADDFHXL).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/ADDFX1 and fast_vdd1v2/ADDFX1).  Deleting (fast_vdd1v2/ADDFX1).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/ADDFX2 and fast_vdd1v2/ADDFX2).  Deleting (fast_vdd1v2/ADDFX2).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/ADDFX4 and fast_vdd1v2/ADDFX4).  Deleting (fast_vdd1v2/ADDFX4).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/ADDFXL and fast_vdd1v2/ADDFXL).  Deleting (fast_vdd1v2/ADDFXL).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/ADDHX1 and fast_vdd1v2/ADDHX1).  Deleting (fast_vdd1v2/ADDHX1).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/ADDHX2 and fast_vdd1v2/ADDHX2).  Deleting (fast_vdd1v2/ADDHX2).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/ADDHX4 and fast_vdd1v2/ADDHX4).  Deleting (fast_vdd1v2/ADDHX4).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/ADDHXL and fast_vdd1v2/ADDHXL).  Deleting (fast_vdd1v2/ADDHXL).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/AND2X1 and fast_vdd1v2/AND2X1).  Deleting (fast_vdd1v2/AND2X1).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/AND2X2 and fast_vdd1v2/AND2X2).  Deleting (fast_vdd1v2/AND2X2).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/AND2X4 and fast_vdd1v2/AND2X4).  Deleting (fast_vdd1v2/AND2X4).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/AND2X6 and fast_vdd1v2/AND2X6).  Deleting (fast_vdd1v2/AND2X6).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/AND2X8 and fast_vdd1v2/AND2X8).  Deleting (fast_vdd1v2/AND2X8).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/AND2XL and fast_vdd1v2/AND2XL).  Deleting (fast_vdd1v2/AND2XL).
Warning : Multiply-defined library cell. [LBR-22]
        : Library-cell name collision (fast_vdd1v0/AND3X1 and fast_vdd1v2/AND3X1).  Deleting (fast_vdd1v2/AND3X1).
Warning : Maximum message print count reached. [MESG-11]
        : Maximum print count of '20' reached for message 'LBR-22'.
  Setting attribute of root '/': 'library' = /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/fast_vdd1v0_basicCells.lib /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/fast_vdd1v0_extvdd1v0.lib /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/fast_vdd1v0_extvdd1v2.lib /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/fast_vdd1v0_multibitsDFF.lib /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/fast_vdd1v2_basicCells.lib /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/fast_vdd1v2_extvdd1v0.lib /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/fast_vdd1v2_extvdd1v2.lib /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/fast_vdd1v2_multibitsDFF.lib /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/slow_vdd1v0_basicCells.lib /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/slow_vdd1v0_extvdd1v0.lib /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/slow_vdd1v0_extvdd1v2.lib /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/slow_vdd1v0_multibitsDFF.lib /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/slow_vdd1v2_basicCells.lib /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/slow_vdd1v2_extvdd1v0.lib /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/slow_vdd1v2_extvdd1v2.lib /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/timing/slow_vdd1v2_multibitsDFF.lib
@file(synth.tcl) 7: set_db / .lef_library $LEF_FILES
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M2_M1_HV' has no resistance value.
        : If this is the expected behavior, this message can be ignored.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M2_M1_VV' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M2_M1_VH' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M2_M1_HH' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M2_M1_2x1_HV_E' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M2_M1_2x1_HV_W' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M2_M1_1x2_HV_N' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M2_M1_1x2_HV_S' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M3_M2_VH' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M3_M2_HH' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M3_M2_HV' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M3_M2_VV' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M3_M2_M_NH' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M3_M2_M_SH' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M3_M2_2x1_VH_E' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M3_M2_2x1_VH_W' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M3_M2_1x2_VH_N' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M3_M2_1x2_VH_S' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M4_M3_HV' has no resistance value.
Info    : Via with no resistance will have a value of '0.0' assigned for resistance value. [PHYS-129]
        : Via 'M4_M3_VV' has no resistance value.
Warning : Maximum message print count reached. [MESG-11]
        : Maximum print count of '20' reached for message 'PHYS-129'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'DFF2RX1' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_multibitsDFF.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'DFF2RX2' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_multibitsDFF.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'DFF2X1' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_multibitsDFF.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'DFF2X2' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_multibitsDFF.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'DFF4RX1' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_multibitsDFF.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'DFF4RX2' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_multibitsDFF.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'DFF4X1' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_multibitsDFF.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'DFF4X2' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_multibitsDFF.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'SDFF2RX1' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_multibitsDFF.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'SDFF2RX2' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_multibitsDFF.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'SDFF4RX1' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_multibitsDFF.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'SDFF4RX2' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_multibitsDFF.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'SPDFF2RX1' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_multibitsDFF.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'SPDFF2RX2' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_multibitsDFF.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'SPDFF4RX1' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_multibitsDFF.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'SPDFF4RX2' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_multibitsDFF.lef'.
Warning : MASTERSLICE layer found after ROUTING or CUT layer. [PHYS-120]
        : MASTERSLICE layer 'PWdummy' is defined after ROUTING layer 'Metal11'.
        : Masterslice layers are typically polysilicon layers. You must define layers in process order from bottom to top. Correct the layer order in the LEF file.
Warning : MASTERSLICE layer found after ROUTING or CUT layer. [PHYS-120]
        : MASTERSLICE layer 'Nwell' is defined after ROUTING layer 'Metal11'.
Warning : MASTERSLICE layer found after ROUTING or CUT layer. [PHYS-120]
        : MASTERSLICE layer 'Oxide' is defined after ROUTING layer 'Metal11'.
Warning : MASTERSLICE layer found after ROUTING or CUT layer. [PHYS-120]
        : MASTERSLICE layer 'Poly' is defined after ROUTING layer 'Metal11'.
Warning : Routing layers are defined in previous LEF file already. [PHYS-109]
        : Routing layers are defined already, this layer 'Metal1' in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_tech.lef' is ignored.
Warning : Routing layers are defined in previous LEF file already. [PHYS-109]
        : Routing layers are defined already, this layer 'Metal2' in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_tech.lef' is ignored.
Warning : Routing layers are defined in previous LEF file already. [PHYS-109]
        : Routing layers are defined already, this layer 'Metal3' in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_tech.lef' is ignored.
Warning : Routing layers are defined in previous LEF file already. [PHYS-109]
        : Routing layers are defined already, this layer 'Metal4' in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_tech.lef' is ignored.
Warning : Routing layers are defined in previous LEF file already. [PHYS-109]
        : Routing layers are defined already, this layer 'Metal5' in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_tech.lef' is ignored.
Warning : Routing layers are defined in previous LEF file already. [PHYS-109]
        : Routing layers are defined already, this layer 'Metal6' in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_tech.lef' is ignored.
Warning : Routing layers are defined in previous LEF file already. [PHYS-109]
        : Routing layers are defined already, this layer 'Metal7' in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_tech.lef' is ignored.
Warning : Routing layers are defined in previous LEF file already. [PHYS-109]
        : Routing layers are defined already, this layer 'Metal8' in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_tech.lef' is ignored.
Warning : Routing layers are defined in previous LEF file already. [PHYS-109]
        : Routing layers are defined already, this layer 'Metal9' in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_tech.lef' is ignored.
Warning : Routing layers are defined in previous LEF file already. [PHYS-109]
        : Routing layers are defined already, this layer 'Metal10' in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_tech.lef' is ignored.
Warning : Routing layers are defined in previous LEF file already. [PHYS-109]
        : Routing layers are defined already, this layer 'Metal11' in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_tech.lef' is ignored.
Warning : Site already defined before, duplicated site will be ignored. [PHYS-106]
        : Site 'CoreSite' read already, this site in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_tech.lef' is ignored.
Warning : Site already defined before, duplicated site will be ignored. [PHYS-106]
        : Site 'IOSite' read already, this site in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_tech.lef' is ignored.
Warning : Site already defined before, duplicated site will be ignored. [PHYS-106]
        : Site 'CornerSite' read already, this site in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_tech.lef' is ignored.
Warning : Site already defined before, duplicated site will be ignored. [PHYS-106]
        : Site 'CoreSiteDouble' read already, this site in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_tech.lef' is ignored.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'ACHCONX2' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045_backbias/lef/gsclib045_backbias_macro.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'ADDFHX1' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045_backbias/lef/gsclib045_backbias_macro.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'ADDFHX2' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045_backbias/lef/gsclib045_backbias_macro.lef'.
Warning : Duplicate macro definition. [PHYS-107]
        : Macro 'ADDFHX4' is already defined. Ignoring this definition in file '/eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045_backbias/lef/gsclib045_backbias_macro.lef'.
Warning : Maximum message print count reached. [MESG-11]
        : Maximum print count of '20' reached for message 'PHYS-107'.

  According to lef_library, there are total 11 routing layers [ V(5) / H(6) ]

  Libraries have 330 usable logic and 163 usable sequential lib-cells.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell FILL1 cannot be found in library.
        : Ensure that the proper library files are available and have been imported.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell FILL16 cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell FILL2 cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell FILL32 cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell FILL4 cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell FILL64 cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell FILL8 cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell NWELLTAP cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell ACHCONX2HVT cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell ADDFHX1HVT cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell ADDFHX2HVT cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell ADDFHX4HVT cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell ADDFHXLHVT cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell ADDFX1HVT cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell ADDFX2HVT cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell ADDFX4HVT cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell ADDFXLHVT cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell ADDHX1HVT cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell ADDHX2HVT cannot be found in library.
Warning : Physical cell not defined in library. [PHYS-279]
        : The physical (LEF) cell ADDHX4HVT cannot be found in library.
Warning : Maximum message print count reached. [MESG-11]
        : Maximum print count of '20' reached for message 'PHYS-279'.
  Setting attribute of root '/': 'lef_library' = /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045_tech//lef/gsclib045_tech.lef /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_macro.lef /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_multibitsDFF.lef /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045/lef/gsclib045_tech.lef /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045_backbias/lef/gsclib045_backbias_macro.lef /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045_hvt/lef/gsclib045_hvt_macro.lef /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045_lvt/lef/gsclib045_lvt_macro.lef
@file(synth.tcl) 8: set_db / .qrc_tech_file $QRC_FILES

  According to qrc_tech_file, there are total 11 routing layers [ V(5) / H(6) ]

  Setting attribute of root '/': 'qrc_tech_file' = /eda/kits/cadence/45nm/gsclib045_all_v4.4/gsclib045_tech//qrc/qx/gpdk045.tch
@file(synth.tcl) 10: set_db / .design_process_node 45
  Setting attribute of root '/': 'design_process_node' = 45
@file(synth.tcl) 12: set_db auto_ungroup both
  Setting attribute of root '/': 'auto_ungroup' = both
@file(synth.tcl) 15: read_hdl -sv ../src/include/cv32e40s_pkg.sv
@file(synth.tcl) 17: foreach sv_file [glob -nocomplain ../src/*.sv] {
	read_hdl -sv $sv_file
}
@file(synth.tcl) 23: set_db flowControl.numThreads 8
Error   : <Start> word is not recognized. [TUI-182] [set_db]
        : 'flowControl.numThreads' is not a recognized object/attribute. Type 'help root:' to get a list of all supported objects and attributes.
        : Check if the given <Start> word is a valid object_type, object or attribute.
#@ End verbose source ../tcl/synth.tcl
1
Encountered problems processing file: ../tcl/synth.tcl
@genus:root: 2> help root:
Obj_type root: 
  Attribute:
    base_name: (string):
                        # Object base (i.e. leaf) name.
    obj_type: (string): # Object type.
    name: (string):     # Object name used for get_db/set_db/reset_db queries.
    escaped_name: (string):
                        # Object escaped name.
    categories: (string):
                        # All attribute categories.
    super_thread_servers: (string):
                        # A list of machine names that should be used for super-threading.
    memory_usage: (double):
                        # Current memory consumption (in Mbytes) for this process.
    peak_memory: (double):
                        # Peak memory consumption (in Mbytes) for this process.
    physical_memory_usage: (double):
                        # Physical memory consumption (in Mbytes) for this process plus all its children and their children.
    peak_physical_memory_usage: (double):
                        # Peak physical memory consumption (in Mbytes) for this process plus all its children and their children.
    elapsed_runtime: (int):
                        # Elapsed wall clock time (in seconds) for this process.
    load_average: (double):
                        # Load average of this server for last 15 minutes.
    tcl_return_display_length_limit: (int):
                        # Limits the string length of command results printed by the interpreter.
    information_level: (int):
                        # Control verbosity of the program.  Allowed values are 0-11.
    init_lib_search_path: (string):
                        # Specifies the search path for technology libraries.
    command_log: (string):
                        # Output file for command logging.
    cmd_file: (string): # Output file for command logging.
    stdout_log: (string):
                        # Output file for stdout logging.
    log_file: (string): # Output file for stdout logging.
    script_search_path: (string):
                        # Search path for script files.
    program_name: (string):
                        # Name of this program.
    program_short_name: (string):
                        # Short name of this program.
    platform_wordsize: (int):
                        # Word size of this program.
    program_version: (string):
                        # Version of this program.
    source_verbose: (bool):
                        # Echo commands during script sourcing.
    source_verbose_proc: (bool):
                        # Echo proc body during script sourcing.
    source_verbose_info: (bool):
                        # Echo file name, timestamp, and memory usage during script sourcing.
    source_suspend_on_error: (bool):
                        # Enter suspend mode if an error occurs during script sourcing.
    fail_on_error_mesg: (bool):
                        # Command fails if an error message is issued.
    print_error_info: (bool):
                        # Tool prints errorInfo variable when command fails.
    continue_on_error: (bool):
                        # Continue processing scripts even if an error occurs.
    log_command_error: (bool):
                        # Report failing command in logfile.
    show_report_options: (bool):
                        # Show report options in header.
    report_tcl_command_error: (bool):
                        # Report Tcl command errors (wrong number of arguments or bad command).
    save_history_file: (bool):
                        # Save command history to ~/.genus_history file.
    restore_history_file: (bool):
                        # Restore command history from ~/.genus_history file.
    common_ui: (bool):  # Enable common-UI command mode.
    floorplan_default_blockage_name_prefix: (string):
                        # Set the name prefix of floorplan blockages.
    xm_protect_version: (string):
                        # Version of XM Protect API embedded in the tool.
    attribute_path: (enum):
                        # Type of path name to report during attribute commands.
    prompt_print_cwd: (bool):
                        # Print current working directory in command shell prompt.
    metric_enable: (bool):
                        # Enable metric snapshot capture with create_snapshot.
    path: (string):     # Search path for implicit finds.
    mesg_severity_downgrade: (bool):
                        # Allow message severity to be downgraded.
    get_db_display_limit: (int):
                        # Limits the number of attributes displayed.
    set_db_verbose: (bool):
                        # Verbose for set attribute.
    tcl_partial_cmd_argument_matching: (string):
                        # Specify partial attribute matching handling.
    startup_license: (string):
                        # The primary license name used at startup.
    heartbeat: (int):   # Heartbeat interval (in seconds).
    heartbeat_print_date: (int):
                        # Heartbeat date and time.
    max_cpus_per_server: (int):
                        # Maximum number of active CPUs allowed to be used on one server. Both super-threading and multi-threading respect this limit.
    limited_access_feature: (string):
                        # A list of {feature version} sub-lists to enable limited access features.
    beta_feature: (string):
                        # A list of {feature version} sub-lists to enable beta features.
    write_vlog_line_wrap_limit: (int):
                        # Specifies the number of printable characters on a single line in the written netlist.
    load_libraries_of_inactive_views: (int):
                        # To load libraries of inactive views.
    hide_mmmc_lib_clones: (bool):
                        # Hide MMMC lib clones.
    init_mmmc_version: (int):
                        # MMMC version in use.
    lbr_mmmc_enable_init_design_speedup: (bool):
                        # Enables runtime improvement during loading libraries.
    skip_statetable_check: (bool):
                        # Skip the statetable check for clock gating libcells. Clock-gating logic for the libcell will be derived from 'clock_gating_integrated_cell' liberty attribute.
    exact_match_seq_sync_ctrls: (bool):
                        # Forces the synchronous inputs of flop-flops to be mapped to corresponding library pins where possible.
    lbr_respect_async_controls_priority: (bool):
                        # Consider the liberty description of asynchronous inputs priority for sequential lib_cells.
    lbr_seq_in_out_phase_opto: (bool):
                        # Allows to propagate inverters through sequential instances.
    allow_invalid_primary_power_pins_libcell: (bool):
                        # Library cell having invalid primary_power pins is treated as unusable.
    case_analysis_propagation_for_icg: (enum):
                        # Should timing case analysis propagate logic constants through ICG cells.
    library_setup_lightweight: (enum):
                        # Ignoring groups while loading library for lightweight ispatial.
    support_multi_seq_elements: (bool):
                        # Support library cell having multiple sequential elements.
    support_aae_lib_path_change: (bool):
                        # Support aae when library path soft link changed.
    ignore_pin_error_in_test_cell_function: (bool):
                        # Ignore pin error in the test cell function.
    lbr_use_test_cell_seq: (bool):
                        # Use test cell function if main cell function is unusable.
    support_combo_clock: (bool):
                        # Support data-pins marked as clock on combinational cells.
    support_internal_pg_pins: (bool):
                        # Support internal power and ground pins.
    ignore_attribute_check_during_pin_conversion: (bool):
                        # Ignore liberty attributes check while converting library's logical pin defined as power or ground in LEF.
    support_3Dtable_power_arc: (bool):
                        # Support three dimensional power arc.
    use_default_related_pg_pin_for_aon: (bool):
                        # Use default power or ground pin for the input or output pin's related_power_pin or related_ground_pin of always on buffer or inverter cell respectively.
    limit_lbr_messages: (bool):
                        # Controls the printing of LBR messages.
    suppress_syntech_messages: (bool):
                        # Controls the printing of library parsing messages.
    wireload_mode: (enum):
                        # Wire load mode: 'top', 'enclosed', or 'segmented' (only valid when interconnect mode is wireload, otherwise, this attribute returns 'none').
    wireload_selection: (wireload_selection):
                        # Wire load selection table, 'none', or 'default'.
    active_operating_conditions: (string):
                        # Current operating_conditions object.  To force a reload of the operating_conditions: "::legacy::set_attribute operating_conditions [::legacy::get_attribute active_operating_conditions /] /".
    case_analysis_sequential_propagation: (bool):
                        # Should timing case analysis propagate logic constants through sequential cells.
    ignore_scan_combinational_arcs: (bool):
                        # Should we ignore combinational arcs involving scan pins.
    lbr_ignore_disable_libarc: (bool):
                        # Ignore the library arcs disabled through 'set_disable_timing' command.
    convert_rising_falling_arcs_to_combo_arcs: (bool):
                        # Convert the rising or falling edge arcs of the non clocked pin having no valid setup arc to combinational arcs.
    lbr_clock_isolation_support: (bool):
                        # Do not convert nochange arcs to setup/hold arcs.
    derive_bussed_pins: (bool):
                        # Enable indexed pins (A[0], A[1], ...) to be merged into a bus automatically and to derive bus_type from bus content.
    optimize_net_area: (bool):
                        # Optimizing for net area in global mapping and incremental optimization.true: optimization minimizes total area, i.e. cell and net area; false: net area is ignored for optimization and only cell area minimized.
    timing_library_lookup_drv_per_frequency: (enum):
                        # Interpolation method for 'max_cap' 1D table (linear|worst).
    map_to_master_slave_lssd: (bool):
                        # Set to true to support master-slave-clock flops.
    override_library_max_drc: (bool):
                        # Allow user to override design rule constraints set on library.
    exact_match_seq_async_ctrls: (bool):
                        # Do not tie off (degenerate) asynchronous controls of sequential cells.
    dont_use_qbar_seq_pins: (bool):
                        # Do not use inverted outputs of sequential cells.
    use_nextstate_type_only_to_assign_sync_ctrls: (bool):
                        # Forces to use only nextstate_type for sync control assignment.
    support_appending_libs: (bool):
                        # Enables appending libraries with same names & PVT conditions in different .lib files.
    report_library_message_summary: (bool):
                        # Enables library message summary report.
    use_scan_seqs_for_non_dft: (enum):
                        # Allow the use of scan sequential cells for non-DFT purposes (true|false|degenerated_only).
    honor_valid_location: (bool):
                        # Controls whether to honor the valid location defined on the library cell.
    lbr_convert_n_piece_cap_to_2_piece: (bool):
                        # Enable Syntech support to downgrade the N piece cap models to 2 piece models.
    lbr_infer_cap_range_from_dynamic_pincap_model: (bool):
                        # Enable Syntech support to infer cap range from dynamic pincap.
    lbr_infer_cap_range_from_c1cn_dynamic_pincap_model: (bool):
                        # Enable Syntech support to infer cap range from n-piece dynamic pincap.
    auto_library_domain: (bool):
                        # To create library-domain automatically based on nominal_condition.
    auto_library_domain_threshold: (double):
                        # To set the threshold for auto library-domain creation.
    enable_library_pins_sorting_in_mmmc: (bool):
                        # Sort library pins in MMMC flow.
    time_recovery_arcs: (bool):
                        # Computes timing across recovery arcs as if they were setup arcs.
    use_main_cell_output_function_for_test_cell: (bool):
                        # Use main cell's output function for test cell.
    support_serial_scanin_multibit_cell: (bool):
                        # Support the serial scan input multibit cell in which serial scan input is specified using internal node instead of scan input pin for all the outputs expect the first.
    support_multi_seq_scan_latch: (bool):
                        # Support scan latch library cell defined using 2 latches.
    mark_valid_lp_cell_as_usable: (bool):
                        # Mark valid low power cells as usable.
    disable_when_checks: (bool):
                        # Disable the processing of long when condition having bus operands.
    establish_library_during_lef_loading: (bool):
                        # Establish the library during lef loading.
    bussed_pin_of_single_bitwidth_as_pin: (bool):
                        # Mark the bussed pin with single bitwidth as single pin.
    reload_when_for_macro_cell: (bool):
                        # Reload when condition processing for macro library cell.
    mark_async_pin_using_timing_arcs: (bool):
                        # Mark library pin having recovery or removal timing arcs as asynchronous.
    support_tlatch_group: (bool):
                        # Support library cell having tlatch group.
    support_master_slave_flop: (bool):
                        # Support master slave flop library cell.
    dummy_scmr_iw_cell_in_all_lds: (bool):
                        # Copy dummy std_cell_main_rail IW cell from it's library domain to all other library domains.
    change_cap_precision: (bool):
                        # Change cap precision to 0.001ff.
    treat_non_seq_arc_cell_as_unusable: (bool):
                        # Libcell having non sequential setup arc is treated as unusable if 'timing_disable_non_sequential_checks' is set to false.
    lef_add_power_and_ground_pins: (bool):
                        # Add power and ground pins to existing library cells.
    parse_lib_moments_table: (bool):
                        # Parse library moments table while loading library file.
    library: (string):  # Target library for technology mapping.
    target_library: (string):
                        # Target library for technology mapping.
    link_library: (string):
                        # Link library for instantiated cells in the design.
    operating_conditions: (operating_condition):
                        # Operating condition for timing (from technology library).
    aocv_library: (string):
                        # To specify AOCV library.
    socv_library: (string):
                        # To specify SOCV library.
    aae_enabled: (int): # Switches the accurate delay calculation engine on.
    socv_analysis: (int):
                        # Statistical variation analysis on.
    timing_nsigma_multiplier: (double):
                        # Statistical variation multiplier.
    delaycal_socv_use_lvf_tables: (string):
                        # Use lvf tables in timing [delay|slew|constraint|all].
    delaycal_socv_lvf_mode: (string):
                        # Lvf mode in timing [early_late|moments].
    delaycal_equivalent_waveform_model: (string):
                        # Equivalent waveform mode [none|no_propagation].
    ignore_sigma_arc_inconsistency: (bool):
                        # Ignores sigma arc inconsistency across views during mmmc consistency check.
    lib_avoid_existing_eeq_cell: (bool):
                        # Set avoid lib eeq cells.
    inst_prefix: (string):
                        # Prefix for new instances.
    ungroup_separator: (string):
                        # Separator for ungrouped instances.
    bit_blasted_port_style: (string):
                        # Naming style to be used if mapped ports are bit blasted.
    bus_naming_style: (string):
                        # Naming style to be used to refer to bits of port bus.
    uniquify_naming_style: (string):
                        # Naming style for controlling names of uniquified subdesigns. Should be set before elaboration. Value set after elaboration will not be applicable for uniquify command on already elaborated designs. It will apply only for any new designs.
    uniquify_rename_all: (bool):
                        # Rename all the modules during uniquification.
    group_generate_portname_from_netname: (bool):
                        # Determines whether the port names of a grouped module should be generated based on the names of the nets connected to these ports.
    update_sv_wrapper_post_elab: (bool):
                        # Updates the 'sv_wrapper' string attribute with new port names which are modified after elaboration stage.
    group_instance_suffix: (string):
                        # Suffix to be added to instance name of new group hierarchy.
    init_blackbox_for_undefined: (bool):
                        # When set to true, empty modules are treated as unresolved references.
    current_design: (object):
                        # The current top design.
    write_db_auto_save_user_globals: (bool):
                        # Write tcl variables to database.
    write_db_use_relative_filepath: (bool):
                        # Use file path relative to 'lib_search_path' attribute, while writting out the attributes 'library', 'lef_library', 'qrc_tech_file' and 'cap_table_file' to database.
    hdl_track_filename_row_col: (bool):
                        # Enable/disable HDL file:row:col info tracking on instances.
    optimize_constant_feedback_seqs: (bool):
                        # Allow optimization of uninitialized feedback flip-flops.
    delete_flops_on_preserved_net: (bool):
                        # Allows to delete the flops connected to a preserved net.
    delete_hier_insts_on_preserved_net: (bool):
                        # Allows to delete the hierarchical instances connected to a preserved net.
    ui_respects_preserve: (bool):
                        # Cause netlist editing commands to fail if they would modify preserved logic.
    hdl_unconnected_value: (string):
                        # Connects any undriven signal (undriven input in module or cell instantiation/ undriven output/ undriven signal in a module to the specified value unless the 'none' value is specified.
    hdl_unconnected_input_port_value: (string):
                        # Connects each undriven input pin in a module or cell instantiation to the specified value unless the 'none' value is specified.
    hdl_undriven_output_port_value: (string):
                        # Connects each undriven output port in a module to the specified value unless the 'none' value is specified.
    hdl_undriven_signal_value: (string):
                        # Connects each undriven signal in a module to the specified value unless the 'none' value is specified.
    treat_net_as_analog: (enum):
                        # Mark net as analog if it's driver is analog or atleast one connected pin is analog.
    dp_analytical_opt: (enum):
                        # Specifies the effort level for global datapath optimization.
    dp_area_mode: (bool):
                        # When true, enables datapath optimizations that focus on improving area results.
    boundary_optimize_invert_hpins_renaming_extension: (string):
                        # Extension to be appended on pin or net name, when boundary pin is inverted.
    tns_opto: (bool):   # Optimize all negative slack endpoints.
    constant_prop_through_iso_cell: (bool):
                        # Allow constant propagation through isolation cells.
    write_vlog_bit_blast_mapped_ports: (bool):
                        # Determines whether mapped ports are bit blasted.
    write_vlog_no_negative_index: (bool):
                        # Determines whether negative indices are eliminated in the Verilog output.
    write_vlog_bit_blast_constants: (bool):
                        # Determines whether constants are bit blasted.
    write_vlog_empty_module_for_logic_abstract: (bool):
                        # Writes unresolved references inferred from logic abstracts as empty Verilog modules.
    write_vlog_empty_module_for_black_box: (bool):
                        # Writes unresolved references inferred from black boxes as empty Verilog modules.
    write_vlog_unconnected_port_style: (string):
                        # Specifies the netlisting style for unconnected instance pins (either none/partial/full).
    gen_module_prefix: (string):
                        # Sets a prefix string to prepend to all generated non user-defined subdesign names.
    write_vlog_skip_ilm_modules: (bool):
                        # Skips writing out Verilog for ILM modules.
    hdl_keep_wand_wor_type: (int):
                        # When set to 1 , will retain wand & wor nets in Netlist.
    write_vlog_top_module_first: (bool):
                        # Determines whether top module is written first in the Verilog output.
    write_vlog_declare_wires: (bool):
                        # Specifies whether implicit wires will be declared in netlist (either true or false).
    write_vlog_wor_wand: (bool):
                        # When false, wor (wand) wires are declared as 'wire' rather than 'wor' ('wand').
    write_vlog_bit_blast_bus_connections: (bool):
                        # Determines whether buses are bit blasted.
    write_vlog_simplify_constant: (bool):
                        # Determines whether to simplify constants when writing out.
    write_vlog_preserve_net_name: (bool):
                        # Determines whether to preserve net names present in user input or not.
    write_vlog_convert_onebit_vector_to_scalar: (bool):
                        # Determines whether to write one bit vector as scalar or not.
    write_sv_port_wrapper: (bool):
                        # Writes out System Verilog port Wrapper.
    write_vlog_generic_gate_define: (string):
                        # Write module descriptions for built-in generic gates within 'ifndef', 'endif' Verilog directives.
    write_vlog_bit_blast_tech_cell: (bool):
                        # Determines whether techelt ports are bit blasted.
    optimize_constant_0_flops: (bool):
                        # Allow constant 0 propagation through flip-flops.
    optimize_constant_1_flops: (bool):
                        # Allow constant 1 propagation through flip-flops.
    optimize_merge_flops: (bool):
                        # Allow merging of equivalent flip-flops.
    optimize_seq_x_to: (string):
                        # Value that should be use to optimize constant X sequential instances.
    boundary_optimize_constant_hpins: (bool):
                        # Allow constant propagation through hierarchical boundary pins.
    boundary_optimize_equal_opposite_hpins: (bool):
                        # Allow connection of hierarchical boundary pins through equal/opposite boundary pins.
    boundary_optimize_feedthrough_hpins: (bool):
                        # Allow routing of feedthrough boundary pins around a hierarchical instance.
    boundary_optimize_invert_hpins: (bool):
                        # Allow inversion of hierarchical boundary pins.
    propagate_constant_from_timing_model: (bool):
                        # Allow constant propagation from timing model instances.
    delete_unloaded_insts: (bool):
                        # Control deletion of unloaded hierarchical instances.
    delete_unloaded_seqs: (bool):
                        # Control deletion of unloaded sequential instances.
    auto_partition: (bool):
                        # Create temporary hierarchies based on connectivity to guide optimization.
    auto_ungroup: (enum):
                        # Automatically ungroup user hierarchies to improve optimization.
    auto_ungroup_min_effort: (enum):
                        # Minimum effort during synthesize for automatic ungrouping to kick in.
    optimize_constant_latches: (bool):
                        # Allow constant propagation through latches.
    optimize_merge_latches: (bool):
                        # Allow merging of equivalent latches.
    comb_seq_merge_message_threshold: (int):
                        # Merging message is printed when hier instance has cells more than this threshold value.
    merge_combinational_hier_instances: (bool):
                        # Allow merging of combinational hierarchical instances.
    tns_critical_range: (delay):
                        # Slack to consider critical in logic structuring.
    minimize_uniquify: (bool):
                        # Try to avoid uniquification of subdesigns.
    enable_break_timing_paths_by_mode: (bool):
                        # Break timing paths for specific modes.
    ocv_mode: (bool):   # Break timing paths for specific modes.
    timing_no_path_segmentation: (enum*):
                        # Do not break timing paths at to_pin of specified constraint types.
    init_timing_enabled: (bool):
                        # Indicates the tool is in timing mode.
    init_prototype_design: (bool):
                        # Indicates that the design is a prototype.
    clock_library_cells_root: (lib_cell*):
                        # Library cells  set to be used for logic on all clock paths.
    use_multi_clks_latency_uncertainty_optimize: (bool):
                        # Use multi-clock latencies and uncertainties at a pin in optimization.
    use_multi_clks_latency_uncertainty_report: (bool):
                        # Use multi-clock latencies and uncertainties at a pin in report.
    define_clock_with_new_cost_group: (bool):
                        # Allows define_clock to create a new cost group.
    timing_disable_non_sequential_checks: (bool):
                        # Disable the non_seq_setup timing check arcs from the libraries.
    timing_disable_library_data_to_data_checks: (bool):
                        # Disable the data to data timing check arcs from the libraries.
    enable_data_check: (bool):
                        # Enable set_data_check constraints.
    phys_scan_def_file: (string):
                        # Scan Def file to use during applicable parts of the physical flow.
    read_def_libcell_mismatch_error: (bool):
                        # Control library cell instantiation matching.
    read_def_keep_net_property: (string):
                        # Keep DEF NET with defined property name.
    congestion_effort: (enum):
                        # Congestion optimization effort level.
    phys_fix_multi_height_cells: (bool):
                        # Fix multi height cells.
    phys_legalization_enhancement: (enum):
                        # To turn on enhancement in legalization (true/false/auto/1/0, default:auto).
    phys_premorph_density: (double):
                        # Target maximum density for legalization.
    lef_units: (int):   # Imported LEF UNITS value.
    ilm_keep_async: (bool):
                        # Keep asynchronous paths during create_ilm.
    db_units: (int):    # Database units per micron from LEF or OA techfile.
    route_rules: (route_rule*):
                        # Routing rules.
    phys_assume_met_fill: (double):
                        # Extraction assuming metal fill scale.
    route_early_global_horizontal_supply_scale_factor: (double):
                        # Horizontal supply scale factor.
    route_early_global_vertical_supply_scale_factor: (double):
                        # Vertical supply scale factor.
    route_early_global_num_tracks_per_clock_wire: (int):
                        # Specify special number of tracks per clock wires.
    route_early_global_secondary_pg: (bool):
                        # Specifies whether secondary PG pins needs to be routed.
    design_top_routing_layer: (string):
                        # Specify the highest lef layer name for global and detail routing.
    design_bottom_routing_layer: (string):
                        # Specify the lowest lef layer name for global and detail routing.
    read_def_fuzzy_name_match: (bool):
                        # Enable fuzzy name matching during 'read_def'.
    lef_add_logical_pins: (bool):
                        # Add logical lef pins to existing library cells.
    error_on_lib_lef_pin_inconsistency: (bool):
                        # Error out on library and lef pin inconsistency.
    use_power_ground_pin_from_lef: (bool):
                        # Library cell pin 'use' attribute is inconsistent between lib and LEF. Overrides LEF's value when set to true.
    lef_manufacturing_grid: (double):
                        # LEF MANUFACTURINGGRID value.
    interconnect_mode: (enum):
                        # Interconnect mode: 'ple', 'wireload'.
    ple_parameter_source_priority: (ple_set_type*):
                        # Technology priority for Physical Layout Estimator.
    force_via_resistance: (double):
                        # Via resistance.  This attribute is used to override the value read from a technology file.
    source_of_via_resistance: (string):
                        # The source of via resistance.
    via_resistance: (double):
                        # Average resistance of M1/M2 and M2/M3 vias.
    scale_of_cap_per_unit_length: (double):
                        # Set scale of capacitance per unit length for Physical Layout Estimator.
    scale_of_res_per_unit_length: (double):
                        # Set scale of resistance per unit length for Physical Layout Estimator.
    shrink_factor: (double):
                        # Set shrink factor for scaling LEF and DEF geometries.
    init_lib_phys_consistency_checks: (bool):
                        # Controlling check consistency between timing and physical library.
    lef_library: (string):
                        # Target LEF library for physical technology mapping.
    number_of_routing_layers: (int):
                        # Limit number of routing layers for calculating area/capacitance/resistance per unit length.
    init_lef_files: (string):
                        # List of LEF files that have been read.
    lef_stop_on_error: (bool):
                        # Stop reading LEF library when an error occurs.
    cap_table_file: (string):
                        # Capacitance table file for Physical Layout Estimator.
    qrc_tech_file: (string):
                        # Technology file to replace capacitance table file.
    read_qrc_tech_file_rc_corner: (bool):
                        # Technology file to replace capacitance table file.
    extract_rc_lef_tech_file_map: (string):
                        # Map layers during extraction between LEF library and technology file.
    phys_extra_vias_length_factor: (int):
                        # Add extra via effect for long segment.
    iso_ls_skip_const_prop_loads: (string*):
                        # Type of loads of isolation or level shifters to skip constant propagation.
    init_power_intent_files: (string):
                        # Power intent file(s) read by last 'read_power_intent' command.
    skip_iso_ls_in_pbs: (bool):
                        # Disable sending of iso ls in background.
    cpi_invert_preserved_net: (bool):
                        # Enable inversion on preserved nets for isolation insertion.
    pias_aon_enable_mode_analysis: (bool):
                        # Enable mode analysis for always on buffering.
    pi_disable_aon_buffering: (bool):
                        # Disable always on buffering for some hierarchies where always on cell may not be available.
    cpi_enable_third_domain_buffering: (bool):
                        # Enable buffering in third domain on data to output path of isolation or level shifter cells.
    pi_parser_error_on_missing_objects: (string):
                        # Treat missing objects as error.
    pi_parser_honor_avoided_cells: (bool):
                        # Power intent parser to honor avoid attribute on library cell(s).
    lp_insert_clock_gating: (bool):
                        # Enable/disable RTL clock-gating.
    lp_default_probability: (double):
                        # Default probability for the root.
    lp_default_toggle_rate: (double):
                        # Default signal toggle rate for the root.
    lp_toggle_rate_unit: (string):
                        # Toggle rate time unit.
    lp_power_unit: (string):
                        # Power unit.
    add_pin_name_to_lp_instance: (bool):
                        # Add interface pin name to the low power instance that commit_power_intent inserts for 1801 flow.
    cpi_insert_on_switch_network: (bool):
                        # Enable or disable insertion of isolation and level shifter cells on switch network.
    commit_delete_invalid_iso_ls: (bool):
                        # Delete invalid isolation or level-shifter cells during commit_power_intent.
    isonor_2017: (bool):
                        # Prefer isonor for cell selection.
    cpi_allow_inverted_ls: (bool):
                        # Allow use of level shifters with inverter functionality.
    cpi_allow_avoided_cells: (bool):
                        # Allow use of avoided cells for commit_power_intent.
    timing_defer_mmmc_obj_updates: (bool):
                        # Defer the update of MMMC objects at init_design.
    delay_corner_pd_at_tc_no_timing_derate: (bool):
                        # No set_timing_derate -power_domain is used.
    lp_pso_aware_estimation: (bool):
                        # Enable power calculation considering power domains which are shutoff.
    write_verification_files: (bool):
                        # Specifies whether to write intermediate files to the verification directory, which is specified by the 'verification_directory_naming_style' attribute.
    ovf_mode: (bool):   # Specifies whether to record and write synthesis transformations to aid verification.
    verification_directory_naming_style: (string):
                        # Format of directory in which verification files are written when the 'write_verification_files' attribute is 'true'. The directory will be created if it does not already exist.
    design_flow_effort: (enum):
                        # Specify flow effort level.
    sdc_match_more_slashes: (bool):
                        # Match all slashes as part of the name in the search pattern for the get_pins, get_nets, get_cells commands.
    sdc_filter_match_more_slashes: (bool):
                        # Match slashes in the search pattern of the filter expression for the get_pins, get_nets, get_cells commands.
    write_sdc_use_libset_name_set_dont_use: (bool):
                        # Prefix the libset name when writing out the set_dont_use constraint.
    phys_socv: (bool):  # Enable the physical socv flow.
    init_state: (string):
                        # Indicates the current state of the initialization process.
    init_physical_only: (bool):
                        # Indicates the tool is in physical only mode.
    init_oa_abstract_views: (string):
                        # Name of the view to be used by 'read_physical'.
    init_oa_layout_views: (string):
                        # List of the view names to process.
    init_oa_default_rule: (string):
                        # Constraint group for standard nets.
    init_oa_special_rule: (string):
                        # Constraint group for special nets.
    init_oa_search_libs: (string):
                        # List of OA libraries to search if cells are not found in the OA reference.
    init_oa_ref_libs: (string):
                        # List of OA libraries that were loaded.
    init_ground_nets: (string):
                        # List of global Ground nets.
    init_power_nets: (string):
                        # List of global Power nets.
    init_min_dbu_per_micron: (int):
                        # Minimum DBU per micron.
    sdc_flat_view_default: (bool):
                        # Change to flat netlist view for SDC commands.
    st_launch_wait_time: (int):
                        # Maximum waiting time in minute for super thread launching.
    drc_first: (bool):  # Use DRC costs first.
    drc_max_cap_first: (bool):
                        # Use max_capacitance costs first.
    drc_max_fanout_first: (bool):
                        # Use max_fanout costs first.
    drc_max_trans_first: (bool):
                        # Use max_transition costs first.
    multibit_seqs_members_naming_style: (string*):
                        # Naming style for sequential instances to be merged into multibit cell.
    partition_based_synthesis: (bool):
                        # To perform synthesis in super-threaded mode.
    timing_analysis_type: (enum):
                        # Timing analysis type.
    skip_default_lib_check: (bool):
                        # Skip default library and search in active view's library for buffers/inverters during loop breaking.
    cb_preserve_ports_nets: (bool):
                        # Preserve nets and pins involved in combinational loops as a reference for verification.
    print_ports_nets_preserved_for_cb: (bool):
                        # Print nets and pins preserved for verification.
    timing_analysis_clock_propagation_mode: (enum):
                        # Specify the timing analysis clock propagation mode.
    timing_spatial_derate_chip_size: (double):
                        # Gets the static chip size in micron.
    tim_ignore_data_check_for_non_endpoint_pins: (enum):
                        # Controls how data-to-data check constraints are supported for non-endpoint pins (true, false, sdc_set_data_check_only, or lib_non_seq_setup_only).
    case_analysis_multi_driver_propagation: (enum):
                        # Controls how timing case values are propagated on multi-driven nets (none, favor_0, favor_1,favor_rise, favor_fall or favor_neither).
    fix_min_drcs: (bool):
                        # Fix min_capacitance, min_transition, and min_fanout design rule violations.
    opt_advanced_beta: (bool):
                        # Enables advanced incremental optimization settings.
    use_max_cap_lut: (bool):
                        # Honor frequency based max_cap lut values from library for design rule violations.
    lp_get_state_dependent_lkg_pow: (bool):
                        # To get state independent cell leakage power.
    lp_power_analysis_effort: (enum):
                        # Power analysis effort level.
    power_optimization_effort: (enum):
                        # Optimization effort to be used to optimize power.
    lp_display_negative_internal_power: (bool):
                        # For displaying negative Internal power results.
    power_engine: (enum):
                        # For selecting legacy, joules power engine.
    joules_silent: (bool):
                        # To silence the joules info/warning messages.
    joules_incremental_silent: (bool):
                        # To silence the incremental joules info/warning messages.
    lp_clock_gating_prefix: (string):
                        # Set name prefix for clock-gating objects.
    lp_clock_gating_exceptions_aware: (bool):
                        # Check timing exceptions and copy onto flops during clock-gating.
    lp_clock_gating_infer_enable: (enum):
                        # Use advanced algorithm to infer enable for clock-gating.
    lp_clock_gating_hierarchical: (enum):
                        # Enable hierarchical clock gating.
    lp_clock_gating_enable_new_hierarchical: (bool):
                        # Enable new hierarchical clock gating.
    lp_multi_vt_optimization_effort: (enum):
                        # Multiple-vt leakage power optimization flow.
    lp_iopt_mvt_multipass_flow: (bool):
                        # Controls the Multi-VT optimization in Iopt. 
    opt_leakage_to_dynamic_ratio: (double):
                        # Relative effort for leakage and dynamic power optimization in the range 0.0 to 1.0.
    design_power_effort: (enum):
                        # Power optimization effort.
    lp_insert_clock_gating_incremental: (bool):
                        # Enables the clock gating during incremental optimization. 
    lp_clock_gating_register_aware: (enum):
                        # Enables the register bank aware clock gating insertion.
    lp_insert_discrete_clock_gating_logic: (bool):
                        # To generate clock gating logic by basic libcells if usable integrated clock gating cells are not present in libraries.
    lp_x_transition_probability_count: (double):
                        # Weight of 'X' transition probability count.
    lp_x_transition_toggle_count: (double):
                        # Weight of 'X' transition toggle count.
    lp_z_transition_probability_count: (double):
                        # Weight of 'Z' transition probability count.
    lp_z_transition_toggle_count: (double):
                        # Weight of 'Z' transition toggle count.
    imm_block_view_brightness: (int):
                        # Brightness level of block views. Default value is hundred (100).
    timing_report_time_unit: (enum):
                        # Specify the timing report time unit.
    timing_report_load_unit: (enum):
                        # Specify the timing report load unit.
    timing_report_enable_common_header: (bool):
                        # Report the timing in common_ui format.
    enable_ui_precision: (bool):
                        # Enable ui precision reporting.
    ui_precision: (int):
                        # Specifies the number of significant digits to be displayed in the absence of an explicit precision for any type.
    ui_precision_power: (int):
                        # Specifies the number of significant digits to be displayed for quantities of type 'power'.
    ui_precision_timing: (int):
                        # Specifies the number of significant digits to be displayed for delay type values - including cell and net delays, transitions, arrival and required times, and slacks.
    ui_precision_capacitance: (int):
                        # Specifies the number of significant digits to be displayed for quantities of type 'capacitance'.
    ui_precision_derating: (int):
                        # Specifies the number of significant digits to be displayed for derating factors - such as those specified via set_timing_derate constraints or AOCV derating libraries.
    ui_precision_sensitivities: (int):
                        # Specifies the number of significant digits to be displayed for statistical sensitivity values and SOCV sigma values.
    timing_report_exception_data: (bool):
                        # Report the exception cross-linking information.
    timing_report_unconstrained: (bool):
                        # Report the unconstrained paths.
    timing_report_path_type: (string):
                        # Specify the path type to be used for the timing report.
    timing_report_endpoint_fields: (string*):
                        # Specify the default set of fields to be used for the endpoint timing report.
    timing_report_fields: (enum+):
                        # Specify the default set of fields to be used for the timing report.
    timing_report_default_formatting: (string):
                        # Specify the default format of the timing report.
    use_area_from_lef: (enum):
                        # Controls whether the cell area from the LEF files should be used.
    one_pass_formal_verification: (bool):
                        # Enable a synthesis flow that allows formal verification to perform a single, RTL-to-final netlist comparison.
    dp_ungroup_during_syn_map: (bool):
                        # Allow ungrouping of datapath and ChipWare hierarchies during syn_map.
    dft_rtl_insertion: (bool):
                        # Check whether DFT inserted RTL generation is requested or not.
    pmbist_enable_multiple_views: (bool):
                        # Check whether support for multiple views of the same memory is requested or not.
    pmbist_full_async_reset: (bool):
                        # Allow all PMBIST logic to have full asynchronous reset.
    dft_exclude_tdrc_fail_seg: (bool):
                        # Exclude abstract segments failing tdrc checks while connect scan chains.
    dft_dont_merge_multibit_lockup: (bool):
                        # Sets dont merge multibit on lockups inserted by connect_scan_chains, add_lockup_element.
    dft_clock_waveform_period: (delay):
                        # Default period for test clocks (in picoseconds).
    dft_clock_waveform_divide_period: (int):
                        # Default period denominator for test clocks.
    dft_clock_waveform_rise: (int):
                        # Default rising edge numerator (fraction of period) for test clocks.
    dft_clock_waveform_divide_rise: (int):
                        # Default rising edge denominator for test clocks.
    dft_clock_waveform_fall: (int):
                        # Default falling edge numerator (fraction of period) for test clocks.
    dft_clock_waveform_divide_fall: (int):
                        # Default falling edge denominator for test clocks.
    dft_prefix: (string):
                        # Prefix to DFT-generated object names.
    dft_atpg_executable: (string):
                        # Specifies Encounter Test executable called from Genus.
    et_license_options: (string):
                        # Additional options to pass to when invoking Encounter Test.
    atpg_license_options: (string):
                        # Additional options to pass to when invoking Encounter Test.
    dft_extended_scandef: (bool):
                        # Produce extended scanDEF output to encompass almost all the scan bits in a design.
    dft_scan_style: (enum):
                        # DFT scan style {muxed_scan | clocked_lssd_scan}.
    unmap_scan_flops: (enum):
                        # Whether it is OK to unmap scan flops {false | 0 | not_mapped_for_dft | true | 1}.
    dft_shift_register_identification_mode: (enum):
                        # Identify shift registers under mode setup {logical_only | testmode_only | test_setup | test_setup_shiftenable | testmode_shiftenable}.
    dft_identify_internal_test_clocks: (enum):
                        # Identify internal test clocks as output pins of multi input gates {false | true | no_cgic_hier}.
    dft_report_empty_test_clocks: (bool):
                        # Have dft report commands report information on test clocks that do not drive any registers.
    dft_identify_test_signals: (bool):
                        # Specifies whether TDRC should auto identify test signals. The default value is true.
    dft_identify_top_level_test_clocks: (bool):
                        # Specifies whether TDRC should auto identify top level test clocks. The default value is true.
    dft_propagate_test_signals_from_hookup_pins_only: (bool):
                        # Specifies whether TDRC should propagate test signals values from both the pin and hookup pin or just the hookup pin. The default is false, indicating that test signals values are propagated from both the pin and hookup pin.
    dft_identify_xsource_violations_from_timing_models: (bool):
                        # Identifies x-source violations from output pins of timing models.
    dft_opcg_domain_blocking: (bool):
                        # Enable OPCG domain blocking.
    dft_enable_opcg2_0: (bool):
                        # Enable OPCG 2.0 features.
    dft_opcg_block_input_to_flop_paths: (bool):
                        # Propagate DFT clock information from primary inputs.
    dft_fence_slow_speed_domains: (bool):
                        # Fence slow speed domains.
    dft_scanbit_waveform_analysis: (bool):
                        # Applies additional analysis if test clock waveform data is available to determine if a non-scan element in a chain is a scan bit or a lockup.
    dft_include_controllable_pins_in_abstract_model: (enum):
                        # Enable writing out controllable pins in abstract model {allmodes | none | test_setup}.
    dft_license_scheme: (enum):
                        # Dft tool selection {Modus | Encounter_Test }.
    dft_include_test_signal_outputs_in_abstract_model: (bool):
                        # Enable writing out test signal outputs in abstract model.
    dft_true_time_flow: (bool):
                        # Enables Encounter Test True Time Flow when writing out the ATPG scripts using 'write_et_atpg'.
    dft_enable_wir_function_check: (bool):
                        # Only test signals with certain functions are allowed in the WIR. Disabling this check may result in invalid or unsupported configurations.
    dft_modedef_internal: (bool):
                        # Use internal modedef file for build testmode when writing out the ATPG scripts.
    dft_generate_atpg_no_testpoint_file: (string):
                        # Generates a file for Modus that specifies where testpoints cannot be inserted { auto | auto_plus_user | user_only | none }.
    dft_auto_identify_shift_register: (bool):
                        # Automatically identifies functional shift register segments.
    dft_report_scan_register_quiet: (bool):
                        # Do not print segment and instance info in report_scan_registers.
    dft_use_wck_as_default_wrapper_clock: (bool):
                        # Use fanin/fanout clock if found else use wck clock if present.
    dft_allow_dwc_in_top: (bool):
                        # Do not print segment and instance info in report_scan_registers.
    dft_shift_register_min_length: (int):
                        # Minimum sequential length of the shift register for auto-identification.
    dft_shift_register_max_length: (int):
                        # Maximum sequential length of the shift register for auto-identification.
    dft_shift_register_with_mbci: (bool):
                        # Support shift register with MBCI.
    dft_apply_sdc_constraints: (bool):
                        # Enables generation and application of SDC constraints for DFT constructs.
    dft_shift_timing_mode_name: (string):
                        # DFT shift timing mode name (default: DFT_SHIFT_MODE).
    dft_capture_timing_mode_name: (string):
                        # DFT capture timing mode name (default: DFT_CAPTURE_MODE).
    dft_pmbist_jtag_timing_mode_name: (string):
                        # DFT PMBIST jtag timing mode name (default: DFT_PMBIST_JTAG_MODE).
    dft_pmbist_mda_timing_mode_name: (string):
                        # DFT PMBIST mda timing mode name (default: DFT_PMBIST_MDA_MODE).
    non_dft_timing_mode_name: (string):
                        # Non-DFT timing mode name (default: NON_DFT_MODE).
    dft_boundary_scan_timing_mode_name: (string):
                        # DFT boundary scan timing mode name (default: DFT_BOUNDARY_SCAN_MODE).
    dft_opcg_timing_mode_name: (string):
                        # DFT OPCG timing mode name (default: DFT_OPCG_MODE).
    dft_lbist_shift_timing_mode_name: (string):
                        # DFT LBIST shift timing mode name (default: DFT_LBIST_SHIFT_MODE).
    dft_lbist_capture_timing_mode_name: (string):
                        # DFT LBIST capture timing mode name (default: DFT_LBIST_CAPTURE_MODE).
    dft_modus_version: (double):
                        # Set the Modus version.
    dft_auto_create_chains_as_internal: (bool):
                        # Auto-create scan chains as internal.
    dft_tap_lockup_clock_from_adjacent: (bool):
                        # Connect lock up element clock to adjacent element clock pin.
    retime_move_mux_loop_with_reg: (bool):
                        # Move the feedback mux loop along with the register during retiming.
    retime_async_reset: (bool):
                        # Should flops with asynchronous reset be retimed.
    retime_optimize_reset: (bool):
                        # Determines whether the reset should be dropped if the computation results in a dont_care value.
    retime_verification_flow: (bool):
                        # Control the annotation in the netlist for retiming verification.
    retime_reg_naming_suffix: (string):
                        # Suffix that gets appended to the name of the retimed flops.
    retime_effort_level: (enum):
                        # Set effort level during retiming (high, medium(default), or low).
    retiming_clocks: (object*):
                        # Perform retiming on these clocks.
    retime_preserve_state_points: (bool):
                        # Preserve retiming state points.
    remove_assigns: (bool):
                        # Removes assigns statements and replaces with buffer/inverter. 
    ignore_preserve_in_tiecell_insertion: (bool):
                        # Ignores all preserve setting while inserting tie-cells. 
    use_fast_area_spatial: (bool):
                        # Use parallel area for better runtime recovery.
    driver_for_unloaded_hier_pins: (enum):
                        # Determines how unloaded input and output subdesign ports are handled
	during incremental optimization.
    use_tiehilo_for_const: (string):
                        # Removes constants and replaces with TIEHI or TIELO cells.
    stop_at_iopt_state: (int):
                        # Increment optimization to stop at this state.
    iopt_sequential_duplication: (bool):
                        # Turns on/off sequential duplication during incremental optimization.
    iopt_sequential_resynthesis: (bool):
                        # Turns on/off sequential resynthesis during incremental optimization.
    iopt_sequential_resynthesis_min_effort: (enum):
                        # Minimum effort during incremental optimization for sequential resynthesis to kick in.
    map_to_multiple_output_gates: (bool):
                        # Controls use of multiple output gates during incremental optimization.
    iopt_enable_floating_output_check: (bool):
                        # Controls use of multiple output gates with floating outputs during incremental optimization.
    iopt_force_constant_removal: (bool):
                        # Force constant removal during incremental optimization even if cost worsens.
    iopt_allow_tiecell_with_inversion: (bool):
                        # Allow tiecell with inverter if one of the tie hi/lo cell is not found.
    iopt_ultra_optimization: (bool):
                        # Enables ultra optimization in incremental optimization to achieve best QOR with higher runtime.
    iopt_remap_avoided_cells: (bool):
                        # Replace avoided cells in mapped netlist.
    opt_high_effort_lib_cells: (lib_cell*):
                        # Provide a list of cells to be used for high effort optimization. Dont-use and Dont-touch constraints for these cells will be ignored for high effort optimization.
    show_wns_in_log: (bool):
                        # Affects the optimization log.  When a design has multiple cost-groups,
	print out two additional columns for the worst weighted WNS value
	and the corresponding cost-group.
    physical_aware_multibit_mapping: (enum):
                        # Multibit mapping is guided by placement information of instances.
    use_compatibility_based_grouping: (bool):
                        # Allows to merge 1-bit sequential, combinational and tristate cells into multibit cells based on compatible groups.
    use_multibit_cells: (bool):
                        # Allows to merge 1-bit sequential, combinational, tristate and iso/ls cells into multibit cells.
    bank_based_multibit_inferencing: (bool):
                        # Removes map to multibit register constraint in predefined multibit.
    use_multibit_seq_and_tristate_cells: (bool):
                        # Allows to merge 1-bit sequential and tristate cells into multibit cells.
    use_multibit_combo_cells: (bool):
                        # Allows to merge 1-bit combinational cells into multibit cells.
    multibit_cells_from_different_busses: (bool):
                        # Allows to merge 1-bit sequential and tristate cells from different busses into single multibit cell.
    multibit_seqs_instance_naming_style: (string):
                        # Naming style to be used for newly created sequential multibit instance.
    multibit_seqs_name_concat_string: (string):
                        # Separator string to be used for concatenation when naming multibit sequential instances. Recommended values for Genus-LEC flow are '_MB_' and '_mb_'.
    multibit_combo_name_concat_string: (string):
                        # Separator string to be used for concatenation when naming multibit combinational and special low power cells. Recommended values for Genus-LEC flow are '_MB_' and '_mb_'.
    multibit_short_prefix_string: (string):
                        # Prefix string to be used while using short naming style for multibit instances. Recommended values for Genus-LEC flow are '_CDN_CPX_' .
    multibit_prefix_string: (string):
                        # Prefix string to be used for naming multibit instances. Recommended values for Genus-LEC flow are 'CDN_MBIT' .
    multibit_split_string: (string):
                        # Naming style string to be used for naming single bit instances when source netlist already has the multibit cells. Default value is '_split_' .
    multibit_preserve_inferred_instances: (bool):
                        # Preserve size_delete_ok inferred multibit instances.
    multibit_allow_async_phase_map: (bool):
                        # Allow interchanging async pins for multibit mapping.
    multibit_adaptive_costing: (bool):
                        # Merge into multibit using QoS cost function modified specifically for multibit mapping. Disabling this will revert to using default cost function of incremental optimization.
    force_merge_seqs_into_multibit_cells: (bool):
                        # Merge sequential instances into multibit ignoring qor change.
    force_merge_combos_into_multibit_cells: (bool):
                        # Merge combinational instances into multibit ignoring qor change.
    multibit_preserved_net_check: (bool):
                        # Merge instances into multibit only if no preserve on connected nets.
    multibit_unused_input_value: (string):
                        # Connects each unconnected input pin in Multibit cell to specified value unless 'none' is supplied.
    multibit_auto_exclude_registers_with_exceptions: (bool):
                        # Enable this to automatically apply dont_infer_multibit on all sequential instances with exceptions.By default exceptional instances are merged only when all exceptions are transferable to multibit formed.
    multibit_allow_unused_bits: (bool):
                        # Allows unused bits in multibit instance.
    multibit_debug: (bool):
                        # Logs Multibit Inferencing debug messages.
    multibit_predefined_allow_unused_bits: (bool):
                        # Allows unused bits in predefined multibit.
    use_multibit_iso_cells: (bool):
                        # Allows to merge 1-bit iso cells into multibit cells.
    force_merge_isos_into_multibit_cells: (bool):
                        # Merge combinational instances into multibit ignoring qor change.
    merge_non_scan_to_scan_flops: (bool):
                        # Controls whether non scan single bit flops can be merged to multibit scan flops.
    multibit_allow_sr_head_flop_merge: (bool):
                        # Controls whether head flops of shift register can be merged to multibit.
    incr_retime: (bool):
                        # Do incremental retiming in incremental optimization flow.
    map_drc_first: (bool):
                        # Give preference to 'drc' cost during mapping.
    map_respect_rtl_clk_phase: (bool):
                        # Respect the clock phase specification of registers from the RTL.
    map_prefer_non_inverted_clock_line: (bool):
                        # The tool will try to avoid inserting inverters in the clock line, but if that is not possible still can add them. If set to false, then the tool can chose the solution which is best from QoR point of view, i.e. has no preference for solutions without inverter.
    map_latch_allow_async_decomp: (bool):
                        # Allow implementing the asynchronous control logic externally to the latch.
    boundary_optimize_invert_hpins_rename_nets: (bool):
                        # Rename nets driven by inverted hierarchical boundary output pins.
    proto_feasible_target: (bool):
                        # Controls the feasible target feature to ignore huge negative slack endpoints from target computation and optimization.
    proto_feasible_target_threshold: (delay):
                        # Controls minimum threshold delay for which path_adjust should be applied.
    proto_feasible_target_threshold_clock_pct: (int):
                        # Controls slack to clock period percentage for which path_adjust should be applied.
    proto_feasible_target_adjust_slack_pct: (int):
                        # Controls percentage of slack value to be used as positive adjust value in path_adjust exception.
    incremental_synthesis: (bool):
                        # This attribute has no effect.
    avoid_tied_inputs: (bool):
                        # Avoid creation of tied input pins of mapped gates in mapping if possible.
    iopt_enable_parallelization: (bool):
                        # Enable parallel iopt when super thread servers are set.
    iopt_temp_directory: (string):
                        # Specifies the directory where parallel incremental optimization can write temporary files.
    pbs_db_directory: (string):
                        # Specifies the directory where partition based synthesis can write temporary files.
    pbs_skip_preserved_hier: (bool):
                        # Skip fully preserved hierarchies during partitioning.
    pbs_gen_summary: (string):
                        # Prints the partition metrics summary for the pbs generic stage.
    pbs_map_summary: (string):
                        # Prints the partition metrics summary for the pbs mapping stage.
    pbs_iopt_summary: (string):
                        # Prints the partition metrics summary for the pbs iopt stage.
    dp_postmap_upsize: (bool):
                        # Controls postmap datapath upsizing.
    dp_postmap_downsize: (bool):
                        # Controls postmap datapath downsizing.
    dp_rewriting: (enum):
                        # Controls the datapath rewriting optimization level in 'synthesize -to_generic' (basic/advanced/none).
    dp_perform_rewriting_operations: (enum):
                        # Controls the datapath rewriting optimization level in 'synthesize -to_generic' (basic/advanced/none).
    dp_sharing: (enum): # To control the datapath sharing in 'synthesize -to_generic' (advanced/none).
    dp_perform_sharing_operations: (bool):
                        # To control the datapath sharing in 'synthesize -to_generic' (advanced/none).
    dp_csa: (enum):     # Controls CSA operation in 'synthesize -to_generic' (basic/none).
    dp_perform_csa_operations: (bool):
                        # Controls CSA operation in 'synthesize -to_generic'.
    dp_speculation: (enum):
                        # Controls datapath speculation in 'syn_generic'.
    control_logic_optimization: (enum):
                        # Controls the effort level for optimization of control logic (basic/advanced/none).
    dp_csa_factorize: (enum):
                        # Controls datapath csa_factorize in 'syn_generic'.
    predict_floorplan_enable_during_generic: (bool):
                        # Enable predict_floorplan during generic stage.
    optimize_yield: (bool):
                        # Optimize design for yield.
    syn_generic_effort: (enum):
                        # Effort level for 'syn_generic' command.
    syn_map_effort: (enum):
                        # Effort level for 'syn_map' command.
    syn_opt_effort: (enum):
                        # Effort level for 'syn_opt' command.
    opt_spatial_effort: (enum):
                        # Optimization effort level for 'syn_opt -spatial'. Values can be one of: 'extreme', 'standard', or 'legacy'. The 'legacy' value will be removed in the 21.1 release.
    syn_global_effort: (enum):
                        # Global effort level for all synthesis commands.
    hdl_latch_keep_feedback: (bool):
                        # Controls how explicitly-specified latch stable states (e.g, q <= q) are implemented: with a feedback path from the Q output to the D input (true), or with a latch enable signal (false).
    hdl_ff_keep_explicit_feedback: (bool):
                        # Controls how flip-flop stable states are implemented for feedback assignments that are explicitly specified in the RTL, e.g., D = Q.Explicit feedback is always kept when hdl_ff_keep_feedback is true.
    hdl_ff_keep_feedback: (bool):
                        # Controls how flip-flop stable states are implemented: with a feedback path from the Q output to the D input (true), or with a synchronous enable signal (false).
    hdl_cdfg_early_redundancy_removal: (bool):
                        # Do an early cleanup of redundant steering logic nodes.
    hdl_flatten_complex_port_in_bottom_up_flow: (bool):
                        # Used for creating one dimensional packed version of complex ports in bottom up flow.
    hdl_auto_sync_set_reset: (bool):
                        # When set to true, the set/reset signal will be preserved with the flip-flop during generic optimization.
    cwd_setup_file: (string):
                        # Developer setup file.
    hdl_create_label_for_unlabeled_generate: (bool):
                        # Specifies whether a name is assigned to unnamed generate blocks.
    hdl_vhdl_lrm_compliance: (bool):
                        # Enforces a more strict interpretation of the VHDL LRM.
    hdl_vhdl_preferred_architecture: (string):
                        # Sets the name of preferred architecture to use with an entity when there are multiple architectures.
    hdl_vhdl_read_version: (string):
                        # Specifies the VHDL version to be used when reading VHDL designs.
    hdl_vhdl_environment: (string):
                        # Specifies the selection of the predefined arithmetic libraries.
    hdl_vhdl_case: (string):
                        # Causes the VHDL analyzer to store VHDL identifiers and operators in lower case, upper case, or the case given in the source file.
    hdl_max_loop_limit: (int):
                        # Determines the maximum number of iterations for unfolding a loop construct of any type.
    hdl_max_recursion_limit: (int):
                        # Sets the maximum number of elaborations for recursive instantiations to prevent possible infinite recursions.
    hdl_max_memory_address_range: (int):
                        # Sets the maximum addressable memory range to prevent synthesis of large memories.
    hdl_allow_inout_const_port_connect: (bool):
                        # When set to true, allows constants to be connected to inout ports.
    hdl_preserve_unused_registers: (bool):
                        # When set to true, preserves flip-flops and latches that do not affect any outputs.
    hdl_preserve_unused_flop: (bool):
                        # When set to true, preserves flip-flops that do not affect any outputs.
    hdl_preserve_unused_latch: (bool):
                        # When set to true, preserves latches that do not affect any outputs.
    hdl_error_on_latch: (bool):
                        # An error is issued if a latch is inferred for a design.
    hdl_error_on_logic_abstract: (bool):
                        # An error is issued if a logic abstract is found in a design.
    hdl_auto_async_set_reset: (bool):
                        # Forces use of asynchronous set and reset pins, rather than data input pins, to implement all asynchronous set and reset operations for latches.
    hdl_infer_unresolved_from_logic_abstract: (bool):
                        # When set to true, empty modules are treated as unresolved references.
    hdl_report_case_info: (bool):
                        # When set to true the case pragma information  will be reported.
    hdl_parameter_naming_style: (string):
                        # Format of the suffix added to original module name per each parameter overwrite.
    hdl_use_default_parameter_values_in_name: (bool):
                        # When set to true, uses all parameter values in parameterized module name.
    hdl_use_default_parameter_values_in_design_name: (bool):
                        # When set to true, uses all parameter values in parameterized module name for top-level design or design specified with 'elaborate' command.
    hdl_enable_proc_name: (bool):
                        # Enable generation of instance hdl_proc_name attributes.
    hdl_zero_replicate_is_null: (bool):
                        # Treat zero-length Verilog replication as null instead of as 1'b0.
    hdl_generate_index_style: (string):
                        # Format of 'for generate' block labels.
    hdl_generate_separator: (string):
                        # String used to separate generate block labels.
    hdl_interface_separator: (string):
                        # String used to separate interface elements.
    hdl_use_if_generate_prefix: (bool):
                        # Specifies whether 'if' generate labels should be used to prefix instances.
    hdl_use_for_generate_prefix: (bool):
                        # Specifies whether 'for' generate labels should be used to create instance names.
    hdl_use_block_prefix: (bool):
                        # Whether block statement labels should be used to prefix instances.
    hdl_flatten_complex_port: (bool):
                        # To convert complex ports to vector ports.
    hdl_decimal_parameter_name: (bool):
                        # When set to true it prints out parameters in decimal format.
    hdl_instance_array_naming_style: (string):
                        # Format of instance array labels.
    hdl_parameterize_module_name: (bool):
                        # When set to false, skips all parameter values in parameterized module name for top-level design or design specified with 'elaborate' command.
    hdl_bidirectional_assign: (bool):
                        # When set to true, interprets Verilog continuous assign statements as being bidirectional.
    hdl_new_bidirectional_assign: (bool):
                        # When set to true, interprets Verilog continuous assign statements as being bidirectional.
    hdl_case_sensitive_instances: (string):
                        # When set to false, allows case insensitive name matching for instances in Verilog whose definition exists in VHDL or Verilog files.
    hdl_vhdl_assign_width_mismatch: (bool):
                        # When set to true, allows arrays with size mismatch to be assigned in VHDL.
    hdl_append_generic_ports: (bool):
                        # When set to false, does not append generic port information to the module name.
    hdl_vhdl_range_opto: (bool):
                        # When set to false disables range optimization in VHDL.
    hdl_use_params_in_cell_search: (bool):
                        # This attribute applies to situation when a parameterized module instantiation is resolved with a Liberty complex cell as opposed to an hdl module. When this attribute is true then the name of the cell to be searched contains the information about the parameters. When set to false the search is done with the name of the module but without the parameter information.
    hdl_exclude_params_in_cell_search: (string):
                        # This attribute applies to situation when a parameterized module instantiation is resolved with a Liberty complex cell as opposed to an hdl module. This attribute will contain the list of names of the cells for which the search is done with the name of the module but without the parameter information.
    hdl_auto_exec_sdc_scripts: (bool):
                        # When true, scripts found in the input HDL file are automatically executed at the end of 'elaborate'.
    hdl_enable_real_support: (bool):
                        # Enable elaboration of constant expressions of real type.
    hdl_sv_module_wrapper: (bool):
                        # Enables generation of System Verilog module wrapper.
    hdl_error_on_blackbox: (bool):
                        # An error is issued if a blackbox is found in a design.
    hdl_rename_cdn_flop_pins: (string):
                        # Provides the control to change the pin names of internal flops.
    hdl_rename_cdn_latch_pins: (string):
                        # Provides the control to change the pin names of internal latches.
    hdl_allow_instance_name_conflict: (bool):
                        # Allow a Verilog instance and wire to have the same name.
    hdl_delete_transparent_latch: (bool):
                        # Deletes latches that are always enabled.
    dp_ungroup_separator: (string):
                        # Separator for instance names of datapath components in ungrouped hierarchies.
    hdl_reg_naming_style: (string):
                        # Format for naming register instances.
    hdl_error_on_negedge: (bool):
                        # Specifies that an error be issued when a falling edge-triggered flip-flop is inferred.
    hdl_case_mux_threshold: (int):
                        # Applies to muxes generated for case statements. When the the number of data inputs is less than the threshold, AND/OR logic is generated rather than a mux.
    hdl_index_mux_threshold: (int):
                        # Applies to muxes generated for variable index array references, such as 'y = x[i]'. When the the number of data inputs is less than the threshold, AND/OR logic is generated rather than a mux.
    hdl_max_map_to_mux_control_width: (int):
                        # Specifies the maximum multiplexer size, in terms of the width of the control input, that can be generated for HDL 'case' statements marked with the 'map_to_mux' pragma.
    hdl_preserve_async_sr_priority_logic: (bool):
                        # When true, prevents RC from generating redundant logic when the mapper selects a flip-flop library cell that has the same priority for the asynchronous set and reset operations as is specified in the input HDL.
    hdl_preserve_sync_ctrl_logic: (bool):
                        # Instructs Genus to preserve the sync control logic structure. Setting this attribute can impact QoR.
    hdl_preserve_sync_set_reset: (bool):
                        # Instructs Genus to preserve the sync set/reset control logic structure. Setting this attribute can impact QoR.
    hdl_convert_onebit_vector_to_scalar: (bool):
                        # When set to true converts one bit vector to scalar.
    hdl_bidirectional_wand_wor_assign: (bool):
                        # When set to true treats assignment to wand/wor net type as bidirectional.
    init_hdl_search_path: (string):
                        # Specifies the search path for HDL files.
    hdl_search_path: (string):
                        # Specifies the search path for HDL files.
    hdl_resolve_instance_with_libcell: (bool):
                        # Use a technology element rather than a Verilog module or VHDL architecture for any instantiation.
    hdl_primitive_input_multibit: (bool):
                        # Allow a Verilog primitive gate instantiated in RTL to have multi bit input.
    hdl_use_cw_first: (bool):
                        # Uses a ChipWare component rather than a Verilog module or VHDL architecture for any instantiation.
    hdl_resolve_parameterized_instance_with_structural_module: (bool):
                        # Uses a module named with a parameterized name for any instance of parameterized Verilog modules or VHDL entities.
    hdl_use_parameterized_module_by_name: (bool):
                        # Uses a module named with a parameterized name for any instance of parameterized Verilog modules or VHDL entities.
    input_pragma_keyword: (string):
                        # Specifies pragma keywords.
    hdl_ignore_pragma_names: (string):
                        # Specifies pragmas to be ignored.
    hdl_verilog_defines: (string):
                        # A list of Verilog macro definitions that are passed to read_hdl and read_netlist commands.
    hdl_overwrite_command_line_macros: (bool):
                        # Enables overwriting of command line macros.
    synthesis_off_command: (string):
                        # Specifies the string to detect synthesis_off pragmas.
    synthesis_on_command: (string):
                        # Specifies the string to detect synthesis_on pragmas.
    input_case_decode_pragma: (string):
                        # Specifies the decode case command in input pragmas.
    input_case_cover_pragma: (string):
                        # Specifies the cover case command in input pragmas.
    input_map_to_mux_pragma: (string):
                        # Specifies the 'map_to_mux' command in input pragmas.
    hdl_language: (string):
                        # Specifies the default HDL language mode.
    hdl_sync_set_reset: (string):
                        # Specifies that the listed signals be used to drive flip-flop set/reset pins when possible.
    hdl_async_set_reset: (string):
                        # Specifies that the listed signals be used to drive latch set/reset pins when possible.
    hdl_bus_wire_naming_style: (string):
                        # Format for naming individual bits of bus wires.
    hdl_array_naming_style: (string):
                        # Format for naming individual bits of array variables.
    hdl_record_naming_style: (string):
                        # Format for naming individual bits of record variables.
    hdl_reg_array_naming_style: (string):
                        # Format for naming array type registers.
    hdl_reg_record_naming_style: (string):
                        # Format for naming record type registers.
    hdl_use_port_default_value: (bool):
                        # When true, uses default initial values of VHDL entity input ports.
    hdl_preserve_dangling_output_nets: (bool):
                        # When true, preserves dangling nets connected to instance output ports.
    hdl_nc_compatible_module_linking: (bool):
                        # When true, implements NC compatible binding rules for linking module/entity instantiations with corresponding definitions.
    hdl_link_from_any_lib: (bool):
                        # Resolve an instantiation with a 'unique' binding found across all present libs.
    hdl_track_module_elab_memory_and_runtime: (bool):
                        # Track elaboration memory and runtime for all modules.
    input_synchro_reset_blk_pragma: (string):
                        # Specifies the 'synchro_reset_blk' command in input pragmas.
    input_synchro_reset_pragma: (string):
                        # Specifies the 'synchro_reset' command in input pragmas.
    input_asynchro_reset_blk_pragma: (string):
                        # Specifies the 'asynchro_reset_blk' command in input pragmas.
    input_asynchro_reset_pragma: (string):
                        # Specifies the 'asynchro_reset' command in input pragmas.
    input_synchro_enable_blk_pragma: (string):
                        # Specifies the 'synchro_enable' command in input pragmas.
    input_synchro_enable_pragma: (string):
                        # Specifies the synchro enable command in input pragmas.
    input_assert_one_cold_pragma: (string):
                        # Specifies the one cold command in input pragmas.
    input_assert_one_hot_pragma: (string):
                        # Specifies the one hot command in input pragmas.
    script_begin: (string):
                        # Specifies the start script command in input pragmas.
    script_end: (string):
                        # Specifies the end script command in input pragmas.
    hdl_preserve_supply_nets: (bool):
                        # Preserve supply nets in user input.
    proto_hdl: (string):
                        # Continue elaboration, in presence of certain types of inconsistencies(e.g. module name case mismatch between module instance and module definition).
    hdl_keep_first_module_definition: (bool):
                        # Keep first seen definition of a module.
    hdl_module_definition_resolution: (string):
                        # Resolves the definition of module in case of clash to first seen module or to last seen module or to module according to the directory rules. It can take four values viz last, first, first_dir_netlist and first_dir_rtl.
    hdl_use_current_dir_before_hdl_search_path: (bool):
                        # Uses current directory before hdl search path.
    frc_treat_modules_as_leaf_insts: (string):
                        # Specifies list of primitive modules.
    hdl_allow_positional_connections_for_pg_inst: (bool):
                        # Allows positional port association for instantiation of cell with power and ground pins..
    selected: (Tcl list):
                        # List of objects selected in the main layout viewer.
    highlighted: (Tcl list):
                        # List of objects highlighted in the main layout viewer.
    obj_types: (obj_type*):
                        # List of 'obj_type' objects.
    messages: (message_group*):
                        # List of 'message_group' objects.
    libraries: (library*):
                        # List of 'library' objects.
    base_cells: (base_cell*):
                        # List of 'base_cell' objects.
    base_cell_sets: (base_cell_set*):
                        # List of 'base_cell_set' objects.
    library_sets: (library_set*):
                        # List of 'library_set' objects.
    opconds: (opcond*): # List of 'opcond' objects.
    rc_corners: (rc_corner*):
                        # List of 'rc_corner' objects.
    timing_conditions: (timing_condition*):
                        # List of 'timing_condition' objects.
    library_domains: (library_domain*):
                        # List of 'library_domain' objects.
    level_shifter_groups: (level_shifter_group*):
                        # List of 'level_shifter_group' objects.
    designs: (design*): # List of 'design' objects.
    vias: (via*):       # List of 'via' objects.
    sites: (site*):     # List of 'site' objects.
    layers: (layer*):   # List of 'layer' objects.
    commands: (command*):
                        # List of 'command' objects.
    flows: (flow*):     # List of 'flow' objects.
    flow_steps: (flow_step*):
                        # List of 'flow_step' objects.
    hdl_libraries: (hdl_lib*):
                        # List of 'hdl_lib' objects.
    dont_report_library: (bool):
                        # Do not report library information in report header.
    dont_report_operating_conditions: (bool):
                        # Do not report operating conditions in report header.
    super_thread_batch_command: (string):
                        # The unix command to submit jobs to a server farm.  Recommended settings are 'bsub -q <queuename> -o /dev/null -J <job_name>' for LSF or 'qsub -q <queuename> -b y -j y -o /dev/null' for SGE.
    super_thread_status_command: (string):
                        # The unix command to get status information about a batch job.  Recommended settings are 'bjobs -l' for LSF or 'qstat -f -j' for SGE.
    super_thread_rsh_command: (string):
                        # The unix command to start a shell on another host (rsh or ssh).
    super_thread_kill_command: (string):
                        # The unix command to cancel a job submitted to a server farm.  Recommended settings are 'bkill -s 9' for LSF or 'qdel' for SGE.
    gui_enabled: (bool):
                        # Returns true if GUI mode is enabled.
    gui_visible: (bool):
                        # Returns true if GUI is visible.
    gui_auto_update: (bool):
                        # Enables automatic GUI updates.
    gui_sv_update: (string):
                        # Set the schematic viewer update mode.
    gui_sv_threshold: (int):
                        # Instance count threshold above which schematic will go into manual update mode.
    gui_hv_threshold: (int):
                        # Set the hierarchy viewer maximum level one branch count.
    gui_hv_phys_threshold: (int):
                        # Set the hierarchy viewer physical instance highlight hierarchy instance count.
    gui_show_old_legend: (bool):
                        # Show the old legend dialog.
    gui_pv_highlight_hier_instances_show_legend: (bool):
                        # Controls the legend dialog from 'gui_highlight_hier_instances_pv'.
    cw_library_version: (string):
                        # The current version of the ChipWare library.
    dft_add_test_compression_new_flow: (bool):
                        # Use unified compression flow in command 'add_test_compression'.
    dft_compression_auto_create: (bool):
                        # Specifies to auto-create any required compression test signals that are missing.
    dft_compression_decompressor_type: (string):
                        # Specifies the decompressor type to insert (elastic | xor).
    dft_compression_compressor_type: (string):
                        # Specifies the compressor type to insert (xor | misr).
    dft_compression_ratio: (int):
                        # Specifies the compression ratio to insert.
    dft_compression_2d_aspect_ratio: (double):
                        # Specifies the aspect ratio of the 2D compression grid to insert.
    dft_compression_channel_length: (int):
                        # Specifies the compression channel length to insert.
    dft_compression_fullscan_support: (bool):
                        # Specifies to insert fullscan muxing to concatenate the compression channels.
    dft_compression_mask_support: (bool):
                        # Specifies to insert compression (wide1) masking.
    dft_compression_mask_sharing_ratio: (int):
                        # Specifies how many compression channels are to share a common mask register.
    dft_compression_lp_gating_support: (bool):
                        # Specifies to insert low power compression channel gating.
    dft_compression_lp_gating_sharing_ratio: (int):
                        # Specifies how many compression channels are to share a common low power gating register.
    dft_compression_num_scanin: (int):
                        # Specifies the number of scan inputs to auto-create for compression.
    dft_compression_num_scanout: (int):
                        # Specifies the number of scan outputs to auto-create for compression.
    dft_compression_elasticity_ratio: (int):
                        # Specifies the SmartScan deserializer ratio to insert for Elastic decompression.
    dft_compression_2d_grid_min_x: (coord):
                        # Specifies the x-coordinate to the right of which the 2D compression grid will be inserted.
    dft_compression_2d_grid_max_x: (coord):
                        # Specifies the x-coordinate to the left of which the 2D compression grid will be inserted.
    dft_compression_2d_grid_min_y: (coord):
                        # Specifies the y-coordinate above which the 2D compression grid will be inserted.
    dft_compression_2d_grid_max_y: (coord):
                        # Specifies the y-coordinate below which the 2D compression grid will be inserted.
    dft_compression_2d_decomp_pipeline_distance: (int):
                        # Specifies the number of 2D compression grid cells between two decompressor pipelines.
    dft_compression_decomp_pipeline_max_xor_depth: (int):
                        # Specifies the maximum XOR depth between two decompressor pipelines.
    dft_compression_comp_pipeline_max_xor_depth: (int):
                        # Specifies the maximum XOR depth between two compressor pipelines.
    dft_compression_scanin_pipeline_depth: (int):
                        # Specifies the number of pipeline stages to insert on every compression scan input.
    dft_compression_scanout_pipeline_depth: (int):
                        # Specifies the number of pipeline stages to insert on every compression scan output.
    dft_compression_masken_pipeline_depth: (int):
                        # Specifies the number of pipeline stages to insert on the compression mask enable signal.
    dft_compression_serial_load_support: (bool):
                        # Specifies to enable loading/unloading the Elastic decompressor, the MISR, the mask register, or the low power gating register serially.
    dft_compression_mask_and_lp_gating_unload_support: (bool):
                        # Specifies to build unload paths for mask and low power gating registers.
    dft_compression_opcg_unload_support: (bool):
                        # Specifies to build unload paths for OPCG programming registers.
    dft_compression_post_2d_sdc_file: (in_file):
                        # Specifies the SDC file to read in after 2D compression is inserted.
    dft_compression_post_2d_sdc_mode_name: (string):
                        # Specifies the name of the timing mode to which the specified SDC file will be applied.
    dft_identify_shared_wrapper_cells: (bool):
                        # Process generic design to identify flops to be used as shared wrapper cells.
    dft_shared_wrapper_through: (string):
                        # Trace through the logic to identify the functional flop in the fanin or fanout of pin location for sharing.
    dft_ignore_dont_scan_for_shared_wrapper_processing: (bool):
                        # Exclude non scan flops while marking wrapper cells.
    dft_process_multibit_for_shared_wrapper: (bool):
                        # Process multibit cells for shared wrapper cells.
    dft_power_aware_wrapper_insertion: (bool):
                        # Power aware wrapper insertion.
    dft_debug_power_aware_wrapper_insertion: (bool):
                        # Debug power aware wrapper insertion.
    dft_ignore_non_scan_ctl_for_wrapper_processing: (bool):
                        # Exclude non scan CTL blocks from wrapper processing.
    dft_ignore_scan_ctl_for_wrapper_processing: (bool):
                        # Exclude scan CTL blocks from wrapper processing.
    dft_exclude_common_logic_from_shared_wrapper_threshold: (bool):
                        # Exclude common logic from shared wrapper threshold calculation.
    dft_shared_common_logic_threshold: (int):
                        # Specifies the threshold for common logic to be included in shared threshold calculation.
    dft_include_direct_fed_logic_to_shared_wrapper_threshold: (bool):
                        # Include the flops which are directly fed by port in shared wrapper threshold calculation.
    dft_ignore_non_scan_icgs_for_wrapping: (bool):
                        # Ignore ICGs that control only non scan logic.
    dft_ignore_timing_models_for_wrapper_processing: (bool):
                        # Ignore timing models for shared wrapper insertion.
    dft_exclude_internal_flops_from_shared_wrapper_threshold: (bool):
                        # Exclude the internal flops from shared wrapper threshold calculation.
    dft_ignore_non_scan_for_wrapper_processing: (bool):
                        # Ignore non scan logic for wrapper insertion.
    dft_ignore_icgs_for_wrapping: (bool):
                        # Ignore ICGs.
    dft_backtrace_from_all_data_pins_of_multibit: (bool):
                        # Trace back from all data pins of multibit instance.
    dft_insert_dedicated_inside_sink_hierarchy: (bool):
                        # Insert dedicated wrapper inside sink hierarchy.
    dft_wait_for_license: (bool):
                        # DFT license checkout will wait for a license if one is not available.
    dft_identify_non_boundary_shift_registers: (bool):
                        # Determines whether identify_shift_register_scan_segments will identify only non-boundary shift registers.
    dft_sdc_input_port_delay: (double):
                        # Default SDC delay value (in ps) for DFT input ports.
    dft_sdc_output_port_delay: (double):
                        # Default SDC delay value (in ps) for DFT output ports.
    dft_boundary_cell_module_prefix: (string):
                        # Specifies the prefix to be added to the boundary scan cell modules.
    dft_jtag_module_name: (string):
                        # Specifies the name of the the JTAG module.
    dft_jtag_instance_name: (string):
                        # Specifies the name of the the JTAG instance.
    timing_analysis_clock_source_paths: (bool):
                        # Disable timing on clock sources.
    free_global_vars_set_by_read_sdc: (bool):
                        # Clean up the global variables set during read_sdc.
    timing_enable_get_ports_for_current_instance: (bool):
                        # Clean up the global variables set during read_sdc.
    detailed_sdc_messages: (bool):
                        # Detailed reporting of messages during read_sdc for easy debug.
    scale_factor_group_path_weights: (int):
                        # Scale the group path weights by this factor if you intend to use floating point weights with dc::group_path -weight (as the internal source code accepts only integer weights). Set it before reading any constraints. Set this attribute to a value which you think will convert all weights to whole numbers - this ensures that all weights are integers and the relative weights across all groups is maintained.
    wccd_threshold_percentage: (double):
                        # Threshold percentage to be specified in the dofile for fpgen and dfpgen flows.
    wclp_lib_statetable: (bool):
                        # Whether 'read library' has the '-statetable' switch.
    clp_treat_errors_as_warnings: (string):
                        # Specify the CLP messages whose severity should be reduced to 'Warning'.
    clp_enable_1801_hierarchical_bbox: (bool):
                        # To enable hierarchical bbox flow for 1801 based design.
    wlec_set_cdn_synth_root: (bool):
                        # Whether to write out the setting for CDN_SYNTH_ROOT in the dofile.
    wlec_no_exit: (bool):
                        # Whether to skip the exit command at end of dofile.
    wlec_lib_statetable: (bool):
                        # Whether 'read library' has the '-statetable' switch.
    wlec_uniquify: (bool):
                        # Whether to have a 'uniquify -all' command.
    wlec_cut_point: (string):
                        # Whether to have 'add cut point' commands for cdn_loop_breakers.
    wlec_analyze_abort: (bool):
                        # Whether to enable 'analyze_abort' flow in LEC.
    wlec_analyze_setup: (bool):
                        # Whether to enable 'analyze setup' flow in LEC.
    wlec_auto_analyze: (bool):
                        # Whether to enable 'auto analyze' in LEC.
    wlec_use_lec_model: (bool):
                        # Whether to use LEC built-in CW/DW models.
    wlec_hier_comp_threshold: (int):
                        # The threshold limit for minimum number of instances in a module in order to perform hierarchical comparison.
    wlec_add_noblack_box_retime_subdesign: (bool):
                        # Whether to write 'add noblack box -submodules' for the retime modules in the dofile.
    wlec_old_lp_ec_flow: (bool):
                        # Switch back to old LP flow to write 'commit cpf -insert'.
    wlec_skip_lvl_check_hier_compare: (bool):
                        # Skip 'Level Shifter' checks in hierarchical compare dofile.
    wlec_skip_iso_check_hier_compare: (bool):
                        # Skip 'Isolation Cell' checks in hierarchical compare dofile.
    wlec_compare_threads: (int):
                        # Specifies number of threads for 'set compare option -threads'.
    wlec_parallel_threads: (int):
                        # Specifies number of threads for 'set parallel option -threads'.
    wcdc_clock_dom_comb_propagation: (string):
                        # To control clock domain propagation through combinational elements in CDC. Valid values are exact_phase or either_phase or wire or logic_phase or logic_nophase.
    wlec_hier_append_string: (string):
                        # When not empty, the value is used as the '-append_string' argument to the Conformal LEC 'write_hier_compare_dofile' command written to the dofile by 'write_do_lec'.
    wlec_hier_compare_string: (string):
                        # When not empty, the value is used as the '-compare_string' argument to the Conformal LEC 'write_hier_compare_dofile' command written to the dofile by 'write_do_lec'.
    wlec_hier_prepend_string: (string):
                        # When not empty, the value is used as the '-prepend_string' argument to the Conformal LEC 'write_hier_compare_dofile' command written to the dofile by 'write_do_lec'.
    wlec_post_add_notranslate_modules: (string):
                        # An extra dofile to be source'd from dofile right after any 'add_notranslate_modules' commands but before  reading the library.
    wlec_low_power_analysis: (bool):
                        # Adds the Conformal Low Power commands to compare the power domains between the golden and revised designs. Power intent must be present.
    wlec_composite_compare: (bool):
                        # Specifies two-step comparison: RTL-to-fv_map and fv_map-to-revised. This attribute has no effect when root attribute 'one_pass_formal_verification' is 'true'.
    wlec_use_smart_lec: (bool):
                        # Adds adaptive-proof commands and information on massively parallel hierarchical compare to the dofile. Conformal Smart LEC license required.
    wlec_gzip_fv_json: (bool):
                        # Compress the implementation information files. Conformal 19.10-s300 or newer is required to execute the dofile.
    wlec_verbose: (bool):
                        # Add more verbose reports to the dofile.
    wlec_run_hier_check_noneq: (bool):
                        # Adds '-check_noneq' option to run_hier_compare / go_hier_compare.
    wlec_dft_constraint_file: (string):
                        # DFT constraints file. This file must exist when verification is performed.
    wlec_no_dft_constraints: (bool):
                        # Do not include automatically generated DFT constraints in the dofile.
    wlec_multithread_license_list: (string):
                        # Specifies the license, or a list of licenses, to use for multi-threaded processing. If an empty string, the LEC default list will be used.
    wlec_black_box_ilm_modules: (bool):
                        # Black box the ILM modules.
    enable_aon_type_in_remove_assign: (bool):
                        # Enable always on type in remove assign.
    ignore_clock_path_check: (bool):
                        # Allow data path instances present in fanout of the clock path.
    mtdcl_traverse_by_level: (bool):
                        # Traverse Instances in clock path 1 level at a time.
    enable_xor_gating_during_map: (bool):
                        # Apply xor based gating during mapping.
    invs_gzip_interface_files: (bool):
                        # Compress Innovus interface files for batch jobs.
    phys_checkout_innovus_license: (bool):
                        # Checkout Innovus license for running placement batch job.
    invs_timing_driven_place: (bool):
                        # Use timing driven option when generating prototype placement. This attribute setting will not impact the flow anymore as the default setting is always true.
    invs_pre_place_opt: (bool):
                        # Perform buffer & inverter pair removal during placement.
    invs_place_opt_design: (bool):
                        # Enable concurrent placement and optimization flow in Innovus.
    invs_clk_gate_recloning: (bool):
                        # Perform Clock Gate Recloning during placement.
    invs_module_plan: (bool):
                        # This attribute is not supported as Innovus has obsoleted the support.
    invs_preload_script: (string):
                        # Script to include in Innovus setup file prior to setup steps.
    design_process_node: (int):
                        # Value for 'design_process_node' in Innovus. User set or may be derived from 'design_mode_node'.
    design_mode_node: (string):
                        # Sets the design_mode_node value in Innovus implementation.
    invs_postload_script: (string):
                        # Script to include in Innovus setup file after setup steps.
    invs_postexport_report_script: (string):
                        # Script to only perform reporting after design export from Innovus.
    invs_preexport_script: (string):
                        # Script to include in Innovus batch file prior to data export.
    invs_save_db: (bool):
                        # Attribute to enable saving of Innovus DB in Genus flow.
    invs_enable_useful_skew: (bool):
                        # Attribute to enable the useful skew flow in Innovus optimization.
    invs_user_mode_file: (string):
                        # Additional mode file to include in Innovus data set.
    invs_user_constraint_file: (string):
                        # Additional constraint file to include in Innovus data set.
    invs_temp_dir: (string):
                        # Directory for Innovus interface files.
    invs_to_genus_colorized_lef_path: (string):
                        # Directory path for storing a copy of the colorized LEF file generated by Innovus.
    invs_power_library_flow: (bool):
                        # Pass the power library and power analysis view to Innovus through multi-mode file.
    invs_opt_leakage: (bool):
                        # Attribute to enable the 'optPower' command in Innovus after place_opt_design.
    invs_write_scandef_options: (string):
                        # Attribute to pass switches to 'write_scandef' command used to write the scan def to be passed to Innovus.
    invs_opt_leakage_options: (string):
                        # Attribute to pass switches to 'optPower' command in Innovus which is run after place_opt_design. For example '-allowResizing'.
    innovus_executable: (string):
                        # Innovus executable to be used for encapsulated runs.
    invs_assign_removal: (bool):
                        # Perform assign removal in Innovus.
    invs_assign_buffer: (string):
                        # Buffer to use for assign removal in Innovus. A setting of 'auto' results in the buffer type being automatically selected. A setting of 'none' results in the use of virtual buffers.
    invs_enable_common_preserve: (bool):
                        # To enable writing of common preserve file for Innovus.
    invs_scanreorder_keepport: (bool):
                        # To pass the 'setScanReorderMode -keepPort <file>' setting to Innovus.
    invs_write_path_groups: (bool):
                        # To enable writing out of all path groups defined in Genus in a separate file, to be sourced in Innovus.
    invs_set_lib_unit: (bool):
                        # To enable writing of timing and capacitance units setting in Innovus setup file, to be sourced in Innovus.
    invs_add_io_buffers: (bool):
                        # Main control to enable all add_io_buffer attributes.
    invs_add_io_buffers_base_name: (string):
                        # Specifies the base name of the added buffer and net.
    invs_add_io_buffers_honor_dont_touch: (bool):
                        # Specifies to exclude dont touch nets while buffering.
    invs_add_io_buffers_exclude_clock_net: (bool):
                        # Specifies not to connect the buffer on clock nets. Need to run time_design to check clock net.
    invs_add_io_buffers_in_cells: (string):
                        # Specifies the cell name or cell names of the input cell buffer. If the specified cell is an inverter, invs_add_io_buffers inserts an inverter pair.
    invs_add_io_buffers_out_cells: (string):
                        # Specifies the cell name or cell names of the output cell buffer. If the specified cell is an inverter, invs_add_io_buffers inserts an inverter pair.
    invs_add_io_buffers_include_nets: (string):
                        # Specifies the of the file that contains the names of the nets to include in the buffer attachment operation.
    invs_add_io_buffers_exclude_nets: (string):
                        # Specifies the of the file that contains the names of the nets to exclude from the buffer attachment operation.
    invs_add_io_buffers_port: (bool):
                        # Specifies whether to prepend the port name to the buffer and net names when base name is not given.
    invs_add_io_buffers_pre_place: (bool):
                        # Specifies if the inverter connected to the port is legally placed and the other inverter is left unplaced.
    invs_add_io_buffers_skip_refine_place: (bool):
                        # Specifies to skip legalization of the new buffer/inverter. Incremental placement needs to be run later to legalize it.
    invs_add_io_buffers_suffix: (string):
                        # Specifies the suffix to use in buffer and net names.
    invs_add_io_buffers_status: (enum):
                        # Specifies the placement status of the added buffer as placed/fixed/softfixed.
    phys_summary_table_print_negative_tns: (bool):
                        # Show TNS numbers as negative in summary table.
    report_ndr_min_layer_count: (bool):
                        # To enable reporting of NDR and Min layer nets count in rep qor and summary table.
    oa_def_file: (string):
                        # The oa_def_file generated by the import_oa_db.
    write_design_create_boundary_opto_file: (bool):
                        # To write out boundary_opto file with write_design -innovus, if this attribute is set to true.
    qos_report_power: (string):
                        # Include leakage and dynamic power in QoS statistics table (true, false, auto).
    def_output_version: (string):
                        # Specify the format version to write.
    def_output_escape_multibit: (bool):
                        # Add escape character before brackets in component names and for bit blasted ports and nets.
    pqos_ignore_scan_chains: (bool):
                        # Ignore scan chains during placement estimation.
    pqos_ignore_msv: (bool):
                        # Do not pass library or power domain information to Innovus.
    pqos_placement_effort: (enum):
                        # Effort level for congestion optimization during Innovus placement (high, medium, low, no_value).
    phys_annotate_ndr_nets: (bool):
                        # Annotate SPEF data for non-default routes and higher metal layer assigned nets.
    phys_flow_effort: (enum):
                        # Effort level for physical optimization flow (high, medium, none).
    phys_legalize: (string):
                        # Enable legalization during physical optimization (true, false, auto).
    phys_mp_constraints: (string):
                        # Encounter planDesign constraint file for floorplan estimation.
    predict_floorplan_constraints: (string):
                        # Innovus planDesign constraint file for floorplan estimation.
    predict_floorplan_script: (string):
                        # Innovus planDesign script file for floorplan estimation.
    predict_floorplan_invs_post_resize_script: (string):
                        # Innovus script file for resize.
    physical_force_predict_floorplan: (bool):
                        # Force or force-inhibit Innovus Master Plan before placement. Default is to analyze for unfixed instances of base-class block.
    invs_launch_servers: (string):
                        # A list of machine names that should be used for launching Innovus batch process.
    invs_memory_usage: (double):
                        # Specifies the peak memory usage by Innovus during 'syn_opt -physical' or 'syn_opt -spatial'.
    phys_pre_place_iopt: (string):
                        # Run fast parallel optimization before placement in the physical flow.
    phys_read_script_large_file_source: (bool):
                        # Should read_script, used only with Genus created '.g' files, use special large file support to bypass Tcl file size limits.
    optimize_constant_across_preserved: (bool):
                        # Enable constant optimization across preserved instances.
    map_clock_tree: (bool):
                        # Enables mapping of all clock logic to a specified set of library cells.
    predict_floorplan_use_innovus: (bool):
                        # Enable newly supported Innovus floorplanning flow.
    predict_floorplan_allow_core_reshape: (bool):
                        # Enable reshape during Innovus predict floorplan.
    predict_floorplan_keep_fences: (bool):
                        # Keep existing fences during Innovus predict floorplan.
    predict_floorplan_keep_fixed_macros: (bool):
                        # Keep fixed macros during Innovus predict floorplan.
    predict_floorplan_skip_propagate_activity: (bool):
                        # Turn off the activity propagation.
    predict_floorplan_enable_cpg: (bool):
                        # Enable Cadence Placement Guidance during Innovus predict floorplan.
    predict_floorplan_allow_illegal_macro: (bool):
                        # Allow illegal macro placement during Innovus predict floorplan.
    predict_floorplan_core_density_size: (bool):
                        # Call create_floorplan after init_design to set aspect_ratio and utilization.
    ilm_disable_internal_paths: (bool):
                        # To disable internal paths in ILM.
    assemble_design_generic_hier: (bool):
                        # Read DEF for generic hierarchy.
    opt_spatial_useful_skew: (bool):
                        # Use useful-skew optimization within Innovus for 'opt_spatial_effort extreme'.
    opt_spatial_early_clock: (bool):
                        # Use early-clock-flow within Innovus for 'opt_spatial_effort extreme'.
    opt_spatial_merge_flops: (enum):
                        # Use flop merging within Innovus for 'opt_spatial_effort extreme'.
    opt_spatial_common_db: (string):
                        # Path of desired 'final' Common-DB from iSpatial process.
    phys_update_preannotation_script: (string):
                        # Script to include during physical database update prior to parasitic annotation step.
    report_logic_levels_histogram_fixed_depth: (int):
                        # To control the depth in report_logic_levels_histogram command. If you set this, '-bar' switch of this command will not be honored.
    disable_power_mode: (bool):
                        # Disable power information in report qor. It will be obsolete in a next major release.
    ets_executable: (string):
                        # Specify the ETS executable to be used for validating timing with RC.
    program_major_version: (string):
                        # Major version of this program (i.e 11.1, 11.2, etc.).
    applet_search_path: (string):
                        # Search path for applet directories.
    applet_mode: (string):
                        # Applet update mode (auto|local|remote).
    applet_server: (string):
                        # Applet server used for dynamic updates(auto|specific address).
    applet_replay: (string):
                        # Records applets successfully loaded for restoration purposes.
    ccd_executable: (string):
                        # Specify the CCD executable to be picked up for generate_constraints and validate_constraints.
    lec_executable: (string):
                        # Specify the CLP executable to be picked up for verify_power_structure and check_cpf.
    clp_ignore_ls_high_to_low: (bool):
                        # Specify if high to low level shifter checks should be skipped.
    statistics_log_data: (bool):
                        # Whether to capture QOR statistics data during synthesis run.
    statistics_enable_power_report: (bool):
                        # Whether to enable the power metrics within stats_db.
    statistics_run_id: (string):
                        # Specifies a user defined unique id for the synthesis run.
    statistics_run_description: (string):
                        # Specifies a description for the synthesis run.
    statistics_db_file: (string):
                        # Specifies the file name for writing out the statistics db file.
    statistics_db_runtime: (double):
                        # Elapsed runtime (in seconds) for the statistics computation.
    super_thread_cache: (string):
                        # Directory where super-thread results are stored.
    max_super_thread_cache_size: (int):
                        # Maximum approximate size allowed for the super-thread cache; a value of zero indicates no limit.
    super_thread_shell_command: (string):
                        # Shell command to execute initial command for super-thread.
    super_thread_debug_directory: (string):
                        # Directory where super-threaded data is saved for debugging purposes.
    super_thread_debug_jobs: (bool):
                        # Dump the debug information for jobs.
    auto_super_thread: (bool):
                        # Automatically launch super-threaded servers during synthesize.
    real_runtime: (double):
                        # Elapsed runtime (in seconds) for this process plus the longest super-thread server(s).
    cpu_runtime: (double):
                        # Elapsed runtime (in seconds) for this process plus all super-thread servers.
    pbs_load_lib_in_group_of: (int):
                        # Only load library on the set value ST servers at a time .
    super_thread_equivalent_licenses: (string):
                        # Licenses that can be checked out for super-thread servers.
    target_tall_percent: (double):
                        # Threshold value for tall cells to be used, short will be 1-target_tall_percent (0 < threshold < 100).
    enable_strict_percent_control: (bool):
                        # Threshold value to be used as hard limit.
    tall_row_tolerance: (double):
                        # Tolerance to add for tall limits for improved optimization (does not apply to doubles).
    short_row_tolerance: (double):
                        # Tolerance to add for short limits for improved optimization (does not apply to doubles).
    short_tall_row_area_ratio: (double):
                        # Ratio of short row area to tall row area.
    short_cell_search_pattern: (string):
                        # In case LEF is not provided, a search pattern is needed to identify which cells are short cells.
    tall_cell_search_pattern: (string):
                        # In case LEF is not provided, a search pattern is needed to identify which cells are tall cells.
    double_cell_search_pattern: (string):
                        # In case LEF is not provided, a search pattern is needed to identify which cells are double cells.
    percent_control_tolerance_for_map: (double):
                        # Tolerance to add for tall and short limits for mapping (does not apply to doubles).
    remove_unusable_rows_during_apply_short_tall: (bool):
                        # During "apply_short_tall_controls" or "apply_short_tall_min_max" remove unusable rows.
    phys_density_based_balancing_max_area_ratio: (double):
                        # Area ratio limit on tall base cell set.
    phys_density_based_balancing_min_area_ratio: (double):
                        # Area ratio limit on short base cell set.
    trigger_post_time_info: (string):
                        # List of procedure and arguments to be executed after 'time_info' is run.
    tinfo_tstamp_file: (string):
                        # Name of '.tstamp' file to save runtime metrics to. '-save' takes precedence over it.
    tinfo_include_load: (bool):
                        # Whether or not time_info output includes system load or not.
    safety_flow_enable: (bool):
                        # Master switch to enable the implementation and analysis of the safety-mechanisms defined in the USF (Unified Safety Format) file.
    safety_tmr_custom_voter_cell: (string):
                        # The custom base-cell or module to perform the voter function for tmr (triple modular redundancy) flops.
			If not defined Genus will create it's own voter logic.
			The base-cell should have either:
				3 inputs and 1 output, or
				3 inputs and 2 complementary outputs.
			The voter-module should be loaded into the design database, and should have:
				3 inputs named: A, B, C.
				And either:
				1 output named: Q (assumed positive), or
				1 output named: QN (assumed negative), or
				2 outputs named: Q, QN
			For single power-domain designs: can only specify one base-cell or voter-module.
				set_db safety_tmr_custom_voter_cell {base_cell}, or
				set_db safety_tmr_custom_voter_cell {voter_module}
			For multi power-domain designs: specify one base-cell or voter-module per domain.
				set_db safety_tmr_custom_voter_cell {{<power_domain_1> <base_cell_1>} {<power_domain_2> <base_cell_2>}}, or
				set_db safety_tmr_custom_voter_cell {{<power_domain_1> <voter_module_1>} {<power_domain_2> <voter_module_2>}}.
    safety_tmr_spacing: (coord):
                        # This is the radial spacing in any direction that should be maintained between the 3 flops in a tmr (triple modular redundancy) group. The value is measured in microns. Attributes "safety_tmr_spacing_x | safety_tmr_spacing_y" and "safety_tmr_spacing" are mutually exclusive.
    safety_tmr_spacing_x: (coord):
                        # This is the horizontal spacing that should be maintained between the 3 flops in a tmr (triple modular redundancy) group. The value is measured in microns. Only one of either "safety_tmr_spacing_x" or "safety_tmr_spacing_y" needs to be met. Attributes "safety_tmr_spacing_x | safety_tmr_spacing_y" and "safety_tmr_spacing" are mutually exclusive.
    safety_tmr_spacing_y: (coord):
                        # This is the vertical spacing that should be maintained between the 3 flops in a tmr (triple modular redundancy) group. The value is measured in microns. Only one of either "safety_tmr_spacing_x" or "safety_tmr_spacing_y" needs to be met. Attributes "safety_tmr_spacing_x | safety_tmr_spacing_y" and "safety_tmr_spacing" are mutually exclusive.
    safety_tmr_isolate_clock: (string):
                        # The type of clock isolation required for tmr (triple modular redundancy) flops.
			# Supported values are:
			# none.
			# unique_driver: the clock pin of every tmr flop should be directly driven by it's own unique clock cell with fanout = 1.
    safety_midas_enable: (string):
                        # Enables USF (Unified Safety Format) technology from Midas.
			  Supported values are:
			  none
			  fmeda   : enable the USF command set for Failure Mode Effect and Diagnostic Analysis. Supported in Genus only.
			  physical: enable the USF command set for physical implementation of safety-mechanisms. Supported in both Genus and Innovus.
    metric_capture_timing_analysis_mode: (string):
                        # Timing analysis mode for metric capture during create_snapshot categories setup and hold; gba, pba, epba, ipba.
    metric_advanced_url_endpoint: (string):
                        # Base URL for the advanced metric server.
    metric_current_run_id: (string):
                        # Current unique run ID returned by the advanced metric server.
    metric_summary_metrics: (string):
                        # Summary metrics to show when creating snapshots.
    metric_category_default: (string):
                        # Default metric categories to capture if none are provided.
    metric_capture_depth: (int):
                        # Depth for capturing hinst design and power metrics.
    metric_capture_min_count: (int):
                        # Minimum instance count for capturing hinst design and power metrics.
    metric_capture_per_view: (bool):
                        # Capture timing metrics per analysis_view.
    metric_capture_timing_paths: (int):
                        # Number of paths to capture for detailed display.
    metric_capture_timing_path_groups: (string):
                        # Defines user path groups to capture for detailed display.
    metric_capture_design_image: (bool):
                        # Capture design image.
    metric_capture_design_image_blockages: (bool):
                        # Capture blockages in design image.
    metric_capture_design_image_power_intent: (bool):
                        # Capture power intent objects in design image.
    metric_capture_design_image_route_drc: (bool):
                        # Capture route drc markers in design image.
    metric_capture_tns_histogram: (bool):
                        # Capture histogram data for TNS.
    metric_capture_pba_tns_histogram: (bool):
                        # Capture path based analysis histogram data for TNS.
    metric_capture_tns_histogram_paths: (int):
                        # Number of paths to capture for the TNS histogram.
    metric_capture_tns_histogram_buckets: (int):
                        # Number of buckets for the TNS histogram.
    metric_capture_tns_histogram_max_slack: (int):
                        # Maximum slack for the TNS histogram.
    metric_capture_max_drc_markers: (int):
                        # Maximum number of DRC markers to include in metric image.
    metric_capture_overwrite: (bool):
                        # Overwrite pending metrics during create_snapshot category capture.
    flow_user_templates: (string):
                        # Flow user template definitions.
    flow_plugin_names: (string):
                        # Names of all internal plug-in points.
    flow_plugin_steps: (string):
                        # List of plug-in steps that have been added through edit_flow.
    flow_template_type: (string):
                        # Type of template being run.
    flow_template_tools: (string):
                        # List of tools included in flow templates being run.
    flow_template_version: (string):
                        # Version of the template being run.
    flow_template_feature_definition: (string):
                        # Features list and status for the current template.
    flow_remark: (string):
                        # Remark from the last flow yaml file loaded.
    flow_features: (string):
                        # Global feature definitions.
    flow_feature_values: (string):
                        # Global feature settings.
    flow_post_db_overwrite: (string):
                        # If set within a skip_db flow_step, it allows the user to identify the name and type of database to present to future flows as the flow_starting_db.
    flow_step_begin_tcl: (string):
                        # Flow tcl run at the start of every step.
    flow_step_end_tcl: (string):
                        # Flow tcl run at the end of every step.
    flow_step_last: (string):
                        # Last flow step to have been completed.
    flow_step_current: (string):
                        # Currently running flow step.
    flow_step_canonical_current: (string):
                        # Currently running canonical flow step.
    flow_step_next: (string):
                        # Next step to run in the flow.
    flow_startup_directory: (string):
                        # Directory where the tool was started.
    flow_working_directory: (string):
                        # Flow directory where the flow is being run.
    flow_branch: (string):
                        # Branch being run for a hierarchical flow.
    flow_caller_data: (string):
                        # Data used by the caller of the tool to identify this flow.
    flow_metrics_file: (string):
                        # Flow metrics file for reporting results.
    flow_metrics_snapshot_parent_uuid: (string):
                        # The snapshot uuid the results from this flow will be appended to.
    flow_metrics_snapshot_uuid: (string):
                        # The snapshot uuid of the most recent flow step executed.
    flow_starting_db: (string):
                        # Starting database for the flow run.
    flow_db_directory: (string):
                        # Flow directory where results databases are stored.
    flow_report_directory: (string):
                        # Flow directory where reports are written.
    flow_log_directory: (string):
                        # Flow directory where log files are stored.
    flow_mail_to: (string):
                        # Email address where results are sent.
    flow_exit_when_done: (bool):
                        # Exit after running final step.
    flow_mail_on_error: (bool):
                        # Email to flow_mail_to if an error is detected.
    flow_summary_tcl: (string):
                        # TCL script to run during run_flow summary.
    flow_history: (string):
                        # Complete flow run history.
    flow_status_file: (string):
                        # File for flow status.
    flow_step_last_status: (string):
                        # Status for the last flow step run.
    flow_step_last_msg: (string):
                        # Message provided for the last step that was run.
    flow_run_tag: (string):
                        # Tags for this particular flow run.
    flow_overwrite_db: (bool):
                        # Enables overwriting databases when saving.
    flow_verbose: (bool):
                        # Enables printing run information in the logfile.
    flow_header_tcl: (string):
                        # TCL script to run when a flow starts.
    flow_footer_tcl: (string):
                        # TCL script to run when a flow ends.
    flow_log_prefix_generator: (string):
                        # TCL script to create log filenames in Flow tool.
    flow_top: (string): # Flow to execute by default.
    flow_hier_path: (string):
                        # Path of current flow within the flow hierarchy.
    flow_schedule: (string):
                        # Set of flows to execute after the current flow completes.
    flow_step_check_tcl: (string):
                        # Procedure to check the steps.
    flow_error_message: (string):
                        # Tcl error message in error database.
    flow_error_errorinfo: (string):
                        # Tcl error stack in error database.
    flow_exclude_time_for_init_flow: (bool):
                        # Marks all snapshots created during the init_flow command as 'exclude_time_metric'. This includes user steps added to the init_flow internal plugin locations.
    flow_error_write_db: (bool):
                        # Write a database when a flow step results in an error condition.
    flow_yamllint_exec: (string):
                        # Yamllint executable command and arguments for checking yaml files.
    flowtool_summary_tcl: (string):
                        # Tcl script to run at the end of flowtool.
    flowtool_metrics_qor_html: (string):
                        # Metrics file to write after tools exit.
    flowtool_metrics_qor_excel: (string):
                        # Metrics file to write after tools exit.
    flowtool_metrics_qor_text: (string):
                        # Metrics file to write after tools exit.
    flowtool_metrics_qor_vivid: (string):
                        # Metrics file to write after tools exit.
    flowtool_exit_timeout: (int):
                        # Maximum amount of time in seconds Flow tool will wait after a tool exits for a completed status.
    flowtool_extra_arguments: (string):
                        # Extra arguments passed to Flowtool when running in tool mode.
    flowtool_predict_full_names: (bool):
                        # Show skip_metric flow name in prediction.
    timing_all_registers_include_icg_cells: (bool):
                        # Controls whether to include ICG cells as register in all_registers -edge_triggered
    timing_allow_input_delay_on_clock_source: (bool):
                        # When set to true allows you to apply input delay constraints on a pin where a clock was previously asserted
    timing_report_clock_pin_as_begin_point: (bool):
                        # Enable whether to show CLK as start point
    timing_aocv_analysis_mode: (enum):
                        # Controls handling of AOCV analysis modes
    timing_aocv_derate_mode: (enum):
                        # Controls the AOCV derating mode
    timing_aocv_slack_threshold: (double):
                        # Analyze aocv slack based at specified threshold
    timing_aocv_stage_count_update_on_timing_reset: (bool):
                        # When set to true, the aocv stage counts are recalculated when timing is reset.
    timing_apply_default_primary_input_assertion: (bool):
                        # When set to true, primary input and bidirectional ports that do not have an explicit arrival time specified are provided a default arrival time
    timing_apply_exceptions_to_data_check_related_pin: (bool):
                        # When set to true, any false path assertion which blocks the data path to the related (-from) pin of the data-to-data check also causes the check to be disabled
    timing_cap_unit: (string):
                        # If set, this value is passed to set_library_unit -cap to set the capacitance units used in timing library and .sdc files and timing reports. Legal values are 1pf and 1ff.
    timing_case_analysis_for_icg_propagation: (enum):
                        # Determines whether constant propagation continues through integrated clock gating (ICG) cells
    timing_case_analysis_for_sequential_propagation: (bool):
                        # When set to true, calculates constants on the outputs of sequential elements
    timing_case_analysis_propagation: (bool):
                        # Overrides sequential and ICG propagation behaviors.
    timing_clock_phase_propagation: (enum):
                        # Lets you select appropriate clock phases at register clock pins when both positive and negative phases of the same clock signal are seen in the clock network
    timing_clock_source_use_driving_cell: (bool):
                        # When set to false, the create_clock command for output pins of cells uses default slew instead of the propagated slew from the primary input ports
    timing_collection_result_display_limit: (int):
                        # Limits the number of objects of a collection to be displayed in the output report
    timing_continue_on_error: (bool):
                        # When set to true, directs software to skip the error and continue processing when an error occurs during timing analysis
    timing_cppr_remove_clock_to_data_pessimism: (bool):
                        # When set to true, removes clock reconvergence pessimism (CRP) for clock source paths
    timing_cppr_self_loop_mode: (bool):
                        # When set to true in case of self-loop paths, computes CPPR adjustment by taking the difference between early and late clock arrival time of the common point
    timing_cppr_skip_clock_reconvergence: (bool):
                        # Specifies the branch point to use for computing clock path pessimism removal (CPPR) adjustment when there is reconvergence in the clock tree
    timing_cppr_threshold_ps: (double):
                        # Specifies the maximum amount of pessimism that clock path pessimism removal (CPPR) analysis is allowed to leave in the path
    timing_cppr_transition_sense: (enum):
                        # Specifies the transition sense of the launching and capturing clocksat the common node, to calculate clock path pessimism removal (CPPR)
    timing_collection_all_fanin_fanout_traversal_mode: (enum):
                        # Controls the way software processes netlist for all_fanin/all_fanout command processing
    timing_create_clock_default_propagated: (bool):
                        # Enables clocks to be created in propagated mode
    timing_default_opcond_per_lib: (bool):
                        # When set to true, use default operating conditions for each lib
    timing_derate_aocv_dynamic_delays: (bool):
                        # This global controls whether or not  AOCV derating factors are applied to the dynamic, SI-induced delay component or not. With a value of '1',  the AOCV derating factor will be applied to both the static and dynamic components of the delay arc. When set to '0', the AOCV derate will only apply to the static component of the delay.
    timing_derate_dynamic_compatibility: (bool):
                        # This global controls how the set_timing_derate factors that are not specified using either -static or -dynamic options are applied to the delay.  When this global is set to '1' the behavior will be compatible with previous releases. In this mode,  the static and dynamic components will be summed before  applying derating.  With a setting of '0',  the static and dynamic components will be derated separately and then combined. A setting of '0' is equivalent to using separate derate assertions with  the -dynamic and -static options explicitly specified.
    timing_disable_inout_output_side_timing_checks: (bool):
                        # When set to false, timing checks on both the input and output sides of the bidirectional pin are analyzed
    timing_disable_bus_contention_check: (bool):
                        # Checks for setup and hold violations in three-state bus designs
    timing_disable_clock_period_checks: (bool):
                        # When set to true, disables timing model clock period checks during timing analysis
    timing_disable_drv_report_on_constant_nets: (bool):
                        # Disables DRV checks for nets having disabled constant propagation:
    timing_disable_floating_bus_check: (bool):
                        # When set to true, disables propagation of minimum delay through three state disable timing arcs and maximum delay through three state enable arcs. These checks are only valid during floating bus conditions
    timing_disable_inferred_clock_gating_checks: (bool):
                        # When set to true, disables clock gating checks that are inferred on combinational elements in the clock path. Explicit clock gating checks that are described in the timing library are not affected by this global variable
    timing_disable_internal_inout_cell_paths: (bool):
                        # When set to false, enables internal bidirectional feedback paths that are completely contained in one instance
    timing_disable_internal_inout_net_arcs: (bool):
                        # When set to true, this global disables internal bidirectional feedback paths that span multiple instances
    timing_disable_lib_pulse_width_checks: (bool):
                        # When set to true, disables timing model pulse width checks during timing analysis
    timing_disable_library_tieoffs: (bool):
                        # Disables constant functions in a library
    timing_disable_netlist_constants: (bool):
                        # When set to true, ignores constants defined in the Verilog netlist
    timing_disable_nochange_checks: (bool):
                        # When set to true, disables no change timing model checks during timing analysis
    timing_disable_output_as_clock_port: (bool):
                        # Controls clock to output port to be treated as data or clock irrespective of constraints set on the port
    timing_disable_parallel_arcs: (bool):
                        # to control enabling/disabling both CTE's  parallel arc reduction, and the related task compression on the AAE side. Setting this variable to 'true' should yield AAE task compression mode '2'.  Setting it to 'false'  will result in task compression mode '0'
    timing_disable_report_header_info: (bool):
                        # Controls whether timing reports are generated using a common report header. 
    timing_disable_retime_clock_path_slew_propagation: (bool):
                        # Controls whether analysis is performed on data or clock paths
    timing_disable_sdf_retain_arc_merging: (bool):
                        # Controls handling of retain arcs in SDF2.1
    timing_disable_skew_checks: (bool):
                        # When set to true, disables library skew checks for timing analysis
    timing_disable_test_signal_arc: (bool):
                        # When set to true, timing analysis will not analyze the signal arcs coming from or going to the test pin
    timing_disable_timing_model_latch_inferencing: (bool):
                        # Controls whether latch behavior is inferred for cell descriptions tagged with the Liberty timing_model_type attribute, including all values: abstracted, extracted, or qtm
    timing_disable_tristate_disable_arcs: (bool):
                        # When set to true, disables all 0/1->Z transitions of tristate arcs during timing analysis
    timing_driving_cell_override_library: (bool):
                        # Controls the selection of library cells specified using the set_driving_cell command
    timing_enable_aocv_slack_based: (bool):
                        # Enable aocv analysis using slack based method
    timing_enable_case_analysis_conflict_warning: (bool):
                        # Controls to report case analysis conflict warnings to CTE_constant_mismatch.rpt file. 
    timing_enable_clock_phase_based_rise_fall_derating: (bool):
                        # Determines the interpretation of edge-specific derating factors for clock paths, specified using the set_timing_derate -rise/-fall parameters
    timing_enable_derating_for_pulse_width_checks: (bool):
                        # Applies check derating for pulse width checks
    timing_enable_early_late_data_slews_for_setuphold_mode_checks: (bool):
                        # When set to true, the global variable enables propagation of early and late slews on data paths. Delay calculation then uses these early and late slews to calculate timing checks. You can use this global in simultaneous setup and hold mode only.
    timing_enable_generated_clock_edge_based_source_latency: (bool):
                        # Controls how the software chooses generated clock source latency paths
    timing_enable_get_obj_escaped_name_backward_compatible: (bool):
                        # Enables printing of escape characters in the get_object_name command output. 
    timing_enable_mmmc_loop_breaking: (bool):
                        # When set to true, loop breaking is handled independently per analysis view
    timing_enable_multi_drive_net_reduction_with_assertions: (enum):
                        # Controls whether multi-drive net reduction (if enabled) will attempt to reduce mult-drive nets that also have only either/both set_annotated_delay or set_annotated_transitions assertions present. By default, any assertions present on different drivers of multi-drive nets will prevent reduction of the multi-drive net.
    timing_enable_multi_frequency_latch_analysis: (bool):
                        # Enables multi-frequency latch timing analysis of the latch time borrowing for when a data signal coming to a latch is controlled by a clock with a frequency different to a clock of the latch enabling signal
    timing_enable_pessimistic_cppr_for_reconvergent_clock_paths: (bool):
                        # When set to true, enables pessimistic cppr adjustment for re-convergent clock paths
    timing_enable_power_ground_constants: (bool):
                        # Controls whether case analysis is inferred from power and ground rail connections. 
    timing_enable_preset_clear_arcs: (bool):
                        # Determines whether timing arcs are created to model the transition to active state (assertion) of the preset or clear pin, and the subsequent transition of the output to controlled state
    timing_enable_pulse_latch: (bool):
                        # Enables pulse-latch analysis
    timing_enable_multicycle_data_check_compatibility: (bool):
                        # Enables checking for SDC compatible data checks when set_multicycle_path -start parameter is specified
    timing_enable_si_cppr: (bool):
                        # Enables more accurate CPPR analysis when incremental delays are present and the timing_remove_clock_reconvergence_pessimism global variable is set to true
    timing_report_skip_constraint_loop_check: (bool):
                        # skip reporting of loop in case timing graph inside loop is broken due to create_clock, set_input_delay, set_output_delay defined inside the loop
    timing_report_unconstrained_path_early_late_header: (bool):
                        # When set to true, prints late and early type for unconstrained path
    timing_enable_simultaneous_setup_hold_mode: (bool):
                        # Controls whether setup and hold checks are analyzed separately, or together on the same timing graph
    timing_enable_tristate_clock_gating: (bool):
                        # When this global is set to true, inferred gated-clock checks are added when clock and data signals converge through the tristate enable and data input of tristate buffers
    timing_enable_uncertainty_for_clock_checks: (bool):
                        # Considers clock uncertainty when performing clock checks.
    timing_enable_uncertainty_for_pulse_width_checks: (bool):
                        # When set to true, considers clock uncertainty when performing minimum pulse width checks
    timing_extract_model_ideal_clock_latency_arc: (bool):
                        # Specifies if latency arc from ideal master clock need to be extracted in timing model
    timing_extract_model_slew_propagation_mode: (enum):
                        # Specifies the type of slew propagation to use for generating extracted timing model
    timing_generated_clocks_inherit_ideal_latency: (bool):
                        # When set to true, makes generated clocks to inherit parent's ideal network latency
    timing_get_of_objects_hier_compatibility: (bool):
                        # When set to true, the get_pins -of_objects parameter will return hierarchical leaf pins connected to the specified objects
    timing_hier_obj_name_compatibility: (bool):
                        # Controls how hierarchical delimiters are interpreted in the search pattern, when the -hier parameter is used with the get_* collection command
    timing_ignore_lumped_rc_assertions: (bool):
                        # When set to false, the set_load and set_resistance values override the actual extracted representation
    timing_io_use_clock_network_latency: (enum):
                        # Controls whether network latency of a reference clock is added or not to the data arrival time on the port
    timing_inter_power_domain_derate_flow_use_path_segment_delay_difference: (bool):
                        # When set to true, aocv-pba calculation with launch/capture path segment delay difference based computation using interface power domain (ipd) derate offsets is enabled
    timing_library_generated_clock_use_group_name: (bool):
                        # When set to true, the software uses the generated_clock group name when creating a generated clock from a library-generated clock group
    timing_library_infer_async_pins_from_timing_arcs: (bool):
                        # This global marks the pins as async pins based on the timing arcs associated with the pin.
    timing_library_infer_cap_range_from_ccs_receiver_model: (bool):
                        # When true infer the rise/fall capacitance range values from ccs receiver capacitance model
    timing_library_zero_negative_timing_check_arcs: (bool):
                        # When true check for negative values in timing arcs
    timing_multi_frequency_clock_rounding_factor: (double):
                        # Rounds off irrational numbers so that they can be read appropriately
    timing_null_collection_return_compatibility: (bool):
                        # Allows you to migrate previous release scripts to the new use model
    timing_prefix_module_name_with_library_generated_clock: (bool):
                        # When set to true, the software appends the instance name to the clock pin name when creating a generated clock
    timing_propagate_latch_data_uncertainty: (bool):
                        # When set to true, uses the clock phase associated with a flush latch's data pin as the from clock phase for downstream uncertainty timing calculations
    timing_clock_source_paths_unconstrained_mark_clock_used_as_data: (bool):
                        # global is set to true, is_clock_used_as_data returns true for unconstrained clock source network
    timing_library_read_without_ecsm: (bool):
                        # Switch off loading of ECSM data
    timing_library_read_without_sensitivity: (bool):
                        # Switch off loading of ECSM timing sensitivity data
    timing_recompute_sdf_in_setuphold_mode: (bool):
                        # Controls the recomputing of SDF delays when the software is in simultaneous setup and hold analysis mode
    timing_reduce_multi_drive_net_arcs: (bool):
                        # Controls the reduction of the number of net arcs created for timing analysis for nets driven by parallel buffers
    timing_reduce_multi_drive_net_arcs_threshold: (int):
                        # Sets a threshold number used by the tool to trigger the reduction of timing arcs of nets driven by parallel buffers
    timing_report_enable_markers: (bool):
                        # Enables marker for report_timing for Pin/timing points columns
    timing_report_enable_unique_pins_multiple_capture_clock_paths: (bool):
                        # enables reporting different paths w.r.t ref clocks in unique_pins
    timing_report_enable_max_capacitance_drv_for_constant_nets: (bool):
                        # Enables max capactiance DRV checks for nets having disabled constant propagation
    timing_report_enable_max_path_limit_warning: (bool):
                        # warning message if max_paths option specified is not enough for coverage
    timing_report_enable_si_debug: (bool):
                        # For decision regarding SI attribute debugging through path collection objects
    timing_report_enable_verbose_ssta_mode: (bool):
                        # Enables new format for header in report_timing SOCV mode
    timing_report_generated_clock_info: (bool):
                        # When set to true (the default), generated clock information is automatically added to the report if generated clocks are encountered in either the launching or latching clock paths
    timing_report_group_based_mode: (bool):
                        # Groups paths by clock domain
    timing_report_timing_header_detail_info: (enum):
                        # Controls whether the report_timing reports are generated using the default orextended report header
    timing_report_unconstrained_paths: (bool):
                        # When set to true, the report_timing command reports unconstrained paths if it cannot find a constrained path to report
    timing_report_use_worst_parallel_cell_arc: (bool):
                        # When set to false, setting the -nworst parameter reports several paths by selecting parallel arcs in the library cell between two pins
    timing_resolve_driver_conflicts: (enum):
                        # Resolves values of nets having multiple drivers
    timing_sdf_enable_setuphold_scond_ccond: (bool):
                        # To enable proper generation of SDF (Standard Delay Format) with scond and ccond qualifiers on SETUPHOLD and RECREM timing checks
    timing_self_loop_paths_no_skew_max_depth: (int):
                        # Identifies self-loop paths at the specified depth. 
    timing_self_loop_paths_no_skew_max_slack: (double):
                        # Identifies self-loop paths at the specified threshold
    timing_set_clock_source_to_output_as_data: (bool):
                        # When set to true, causes a clock source path leading to an output or bidi port to be treated as a data path if there is a set_output_delay or set_data_check assertion on the port
    timing_scaling_for_negative_checks: (enum):
                        # Modifies the scaling of the negative timing analysis check value
    timing_scaling_for_negative_delays: (enum):
                        # Modifies the scaling of the negative delay value to be used during timing analysis
    timing_socv_statistical_min_max_mode: (enum):
                        # Controls worstcasing mode to be used for SOCV
    timing_constraint_update_io_latency_averaging_mode: (enum):
                        # Controls the analysis to update io latency for rise and fall both or for rise only
    timing_constraint_enable_logging: (bool):
                        # Enables dumping of constraint command in log file
    timing_suppress_escape_characters: (bool):
                        # Suppresses the reporting of escape characters in timing object names
    timing_suppress_ilm_constraint_mismatches: (bool):
                        # When set to true, the software suppresses all error and warning messages related to objects not found when loading SDC constraint files for the ILM flow
    timing_time_unit: (string):
                        # This value is passed to set_library_unit -time to set the time units used in timing library and .sdc files and timing reports. Legal values are none, 1ns, 1ps, 10ps, 100ps.
    timing_use_incremental_si_transition: (bool):
                        # When set to true, enables usage of incremental slew during DRV violation reporting
    timing_use_latch_early_launch_edge: (bool):
                        # Enables the latch use early launch edge feature.
    timing_use_latch_time_borrow: (bool):
                        # When set to false, does not consider time borrowing during timing analysis. Time borrowing is the amount of time borrowed by a previous logic
    timing_write_sdf_no_escape_backslash: (bool):
                        # Supports various patterns of the escape character.
    timing_cppr_propagate_thru_latches: (bool):
                        # When set to true, the cppr of a timing path crossing a latch (or latches) is calculated using the common pin of its origin flop and the capture device at the end of the path. Otherwise the usual segment-based cppr calculation is performed. This cppr setting is considered only when the latch thru analysis mode is enabled.
    timing_disable_genclk_combinational_blocking: (bool):
                        # Disables blocking of generated clocks with '-combinational' option which are downstream of another generated clock
    timing_enable_latch_thru_mode: (bool):
                        # Enable the latch thru analysis mode in which timing paths can propagate across latches, depending on their arrival time with respect to the latch transparency window.
    timing_extract_model_exhaustive_validation_dir: (string):
                        # Specifies the output directory where the validation reports will be written
    timing_extract_model_exhaustive_validation_mode: (bool):
                        # Enables ETM validation at the minimum and maximum indices of the slew / load indices
    timing_sdf_adjust_negative_setuphold: (bool):
                        # Controls how Setup and Hold check values are adjusted when both are initially negative.
    timing_derate_aocv_reference_point: (int):
                        # Allows specification of reference point for AOCV factors
    timing_derate_ocv_reference_point: (int):
                        # Allows specification of reference point for OCV factors
    timing_enable_latency_through_clock_gating: (bool):
                        # Controls propagation of latency phases across a clock gating element.
    timing_extract_model_aocv_mode: (enum):
                        # This global sets the AOCV mode to be used during model extraction
    timing_extract_model_case_analysis_in_library: (bool):
                        # When set to false, specifies that port propagated constants are written to the generated constraints file
    timing_extract_model_consider_design_level_drv: (bool):
                        # When set to false, specifies that user asserted design level DRVs should not be considered while writing to the extracted timing model
    timing_extract_model_gating_as_nochange_arc: (bool):
                        # When set to false, disables conversion of clock gating checks to nochange arcs in the extracted timing model
    timing_extract_model_disable_cycle_adjustment: (bool):
                        # When set to true, the cycle adjustment for the multcycle-paths that could not be pushed out, is disabled
    timing_extract_model_include_applied_slew_in_characterization_range: (bool):
                        # When set to true, specifies that actual timer slew must be included in the characterization range for timing model.
    timing_library_hold_sigma_multiplier: (double):
                        # User control multiplier to generate constraint table applied for hold arc.
    timing_library_setup_sigma_multiplier: (double):
                        # User control multiplier to generate constraint table using sigma values applied for setup arc.
    timing_report_retime_formatting_mode: (enum):
                        # This variable can be used to manage the retiming fields in reporting format. Based upon given setting it would automatically replaces (or add) the default columns with respective retiming columns. For example in case of delay column it will add(or replace) the 'Retime Delay' automatically.
    timing_use_clock_pin_attribute_for_clock_net_marking: (bool):
                        # To allow the propagation of clocks to pins with clock attributes regardless of the presence of check arcs or trigger arcs at the pins
    timing_normalized_driver_waveform_clip_linear_part: (bool):
                        # To control the clipping of the generated ndw which is generated by the global timing_generate_normalized_driver_waveform.
    timing_normalized_driver_waveform_weight_factor: (double):
                        # Decides the weight factor for the exponential and the linear part in the waveform generated by the global timing_generate_normalized_driver_waveform.
    timing_generate_normalized_driver_waveform: (bool):
                        # To generate ndw if it is not defined in the library.
    timing_constraint_enable_search_path: (bool):
                        # Enable searching of constraint files in search_path directory variable
    timing_constraint_enable_detailed_report_invalid_begin_end_points: (bool):
                        # Enables detailed reporting of invalid begin points/end points specified with set_false_path/set_multicycle_path constraints else only checks structural end points
    timing_enable_path_delay_to_unconstrained_endpoints_compatibility: (bool):
                        # When set to true, does not constrain path with path delay if path ends at unconnected input pin of combo cell.
    timing_library_build_async_deassert_arc: (bool):
                        # Controls whether input to output arcs from the preset or clear pins transitioning to inactivestate are included when the timing system is initialized
    timing_aocv_chip_size: (double):
                        # Specifies the diagonal length of the chip, in microns
    timing_aocv_core_size: (double):
                        # Specifies the diagonal length of the core area, in microns
    timing_enable_genclk_divide_by_inherit_parent_duty_cycle: (bool):
                        # Controls inheritance of duty cycle from master clock for generated clocks with divide by option
    timing_enable_genclk_source_path_register_limit: (bool):
                        # Limits generated clock source latency path to traverse across one register only
    timing_analysis_precision_ps: (double):
                        # Control delay precision 0.1ps or 0.01ps
    timing_cppr_opposite_edge_mean_scale_factor: (double):
                        # Controls mean delay component for CPPR credit for opposite transition edges at common pin
    timing_cppr_opposite_edge_sigma_scale_factor: (double):
                        # Controls sigma delay component for CPPR credit for opposite transition edges at common pin
    timing_cppr_opposite_edge_sigma_scale_factor_net: (double):
                        # Controls net sigma delay component for CPPR credit for opposite transition edges at common pin
    timing_cppr_opposite_edge_sigma_scale_factor_cell: (double):
                        # Controls cell sigma delay component for CPPR credit for opposite transition edges at common pin
    timing_socv_preserve_variation_with_annotations: (bool):
                        # 
    timing_analysis_self_loops_paths_no_skew: (bool):
                        # Eliminates clock skew due to clock uncertainty for a path starting and ending at the same register. If the clock skew is not eliminated, the timing for such paths is pessimistic
    timing_report_constraint_enable_extended_drv_format: (bool):
                        # Enables reporting of report_constraint as per clock/data phases and rise/fall
    timing_path_based_enable_verbose_mode: (enum):
                        # controls the verbosity of path based analysis messages printed during and at the end of the analysis
    timing_property_return_null_collection_with_quiet: (bool):
                        # Enables returning properties values for all objects when -quiet option is used in get_property
    timing_rail_swing_checks_high_voltage_threshold: (double):
                        # user to specify voltage thresholds for high rail swing checks
    timing_rail_swing_checks_low_voltage_threshold: (double):
                        # user to specify voltage thresholds for low rail swing checks
    timing_waveform_aware_pulse_width_checks_high_voltage_level: (double):
                        # User to specify high voltage level to be used for waveform aware pulse-width checks
    timing_waveform_aware_pulse_width_checks_low_voltage_level: (double):
                        # User to specify low voltage level to be used for waveform aware pulse-width checks
    timing_constraint_path_delay_exclude_unconstrained_endpoints: (bool):
                        # When set to true, does not constrain unconstrained path with path delay.
    timing_clock_uncertainty_from_to_precedence: (bool):
                        # Gives higher precedence to clock-to-clock uncertainty when set to true
    timing_path_based_enable_report_launch_clock_path: (bool):
                        # set it to false to skip reporting launch clock path in pba path_type full report
    timing_collection_variable_assignment_compatibility: (bool):
                        # Enables printing names of output of get objects commands when set to false
    timing_check_timing_report_all_checks: (bool):
                        # Enables reporting of all checks performed by check_timing
    timing_report_enable_report_clock_timing_across_clock_pin: (bool):
                        # Enables fanout tracing across clock pins if any combinational arc is present
    timing_report_pulse_width_matching_launch_capture_paths: (bool):
                        # Reports only those pulse_width paths that have same pins on launch and capture path
    timing_path_based_enable_exhaustive_depth_bounded_by_gba: (bool):
                        # Enable the tool to bound the PBA exhaustive analysis by next worst GBA slack incase the depth is exhausted for any given endpoint
    timing_path_based_exhaustive_enable_design_coverage: (bool):
                        # Enables the exhaustive path based analysis to evaluate all violating endpoints
    timing_path_based_exhaustive_max_paths_limit: (int):
                        # Set the maximum number of paths which can be retimed during exhaustive path based analysis
    timing_extract_model_include_applied_load_in_characterization_range: (bool):
                        # When set to true, specifies that actual load visible to timer, will be included in the load characterization range for path endpoints
    timing_extract_model_max_feedthru_characterization_load: (double):
                        # Load specified will be used by model extractor for feed through path characterization.
    timing_report_redirect_message_types: (enum):
                        # Redirect reporting messages to report file
    timing_enable_get_objects_regexp_compatibility: (bool):
                        # Enables the -regexp option compatibility for get_* commands
    timing_path_based_low_memory_mode: (double):
                        # A lower value for this variable will reduce the peak memory footprint of path based analysis (PBA) at the cost of some addition runtime.
    timing_spatial_derate_distance_mode: (enum):
                        # 
    timing_disable_constant_propagation_for_sequential_cells: (bool):
                        # When set to true, disables constant prop. across sequential cells if sequential_prop global is false
    timing_report_drv_enable_frequency_per_view: (bool):
                        # Enables view based frequency drv flow
    timing_property_arrival_window_enable_tcl_dict_format: (bool):
                        # When set to TRUE, new format for the arrival_windows property will be used to print.
    timing_report_property_fastest_clock_consider_data_phase: (bool):
                        # When on, it will consider data phase also while finding the fastest clock.
    timing_constraint_warn_for_timing_derate_exceeding_max_limit: (double):
                        # Sets the limit on derate value for giving the warning in case the larger derate is applied
    timing_constraint_path_delay_exclude_io_delay_from_ignore_clock_latency: (bool):
                        # Excludes input/output delays from set_max/min_delay -ignore_clock_latency slack computation
    timing_cppr_enable_mismatch_transition_mode: (bool):
                        # Enables CPPR compatibility mode when transitions mismatch at the common pin
    timing_derate_negative_delay_backward_compatibility: (bool):
                        # 
    timing_clock_pulse_width_sensitivity_checks_threshold: (double):
                        #  
    timing_report_disable_rts_dsta_flow: (bool):
                        # When true , disable rts calls in dsta flow
    timing_library_hold_constraint_corner_sigma_multiplier: (double):
                        # User control multiplier to generate constraint table applied for hold arc.
    timing_library_setup_constraint_corner_sigma_multiplier: (double):
                        # User control multiplier to generate constraint table using sigma values applied for setup arc.
    timing_library_use_two_piece_receiver_cap: (bool):
                        # When libraries have both 2 piece and multi piece pin caps, give priority to two piece models.

    timing_library_enable_advanced_capacitance_support: (bool):
                        # Enables support for N-piece CCS receiver capacitance and ecsm_capacitance_set groups in libraries
    timing_derate_spatial_distance_unit: (enum):
                        # Set the distance unit.
    timing_extract_model_write_clock_checks_as_arc: (bool):
                        # Allows timing model to write min pulse width  or min period checks as arcs.
    timing_extract_model_write_clock_checks_as_scalar_tables: (bool):
                        # Allows timing model to write min pulse width  or min period checks as  scalar arcs.
    timing_library_convert_async_setuphold_to_recrem: (int):
                        # Controls whether single-edged setup and hold checks on asynchronous pins in the Liberty library are inferred as recovery and removal checks. This is mainly to support older modeling styles in legacy libraries.
    timing_library_infer_cap_range_from_ecsm_receiver_model: (bool):
                        # When this global is enabled would infer cap range from ecsm capacitance group of library.
    timing_library_read_ccs_noise_data: (bool):
                        # can read ccs noise construct from library when enabled.
    timing_library_read_without_power: (bool):
                        # can read library without power by setting this global to true
    timing_library_term_voltage_from_lib_pin: (int):
                        # Use Library pin voltage for reporting the term voltage.
    timing_library_interpolate_drv_values: (bool):
                        # Allows the software to use a range of trilib DRV values for performing delay calculations
    timing_library_scale_aocv_to_socv_to_n_sigma: (double):
                        # AOCV derates are expected to be derived based on 3-sigma variation
    timing_library_infer_socv_from_aocv: (bool):
                        # Infer sensitivity data from AOCV libraries
    timing_analysis_enable_transistor_mode: (bool):
                        # If true, ebnables the transistor level timing analysis mode
    place_design_floorplan_mode: (bool):
                        # run placement in floorplan mode
    place_design_refine_macro: (bool):
                        # specify whether to run refine_macro_place after place_design -concurrent_macro
    place_design_refine_place: (bool):
                        # if set to false, calls to refinePlace from other apps (such as place_opt_design, opt_design) will not run refinePlace
    place_detail_activity_power_driven: (bool):
                        # This attribute is not directly used by Genus but instead, when set, is shared with Innovus.
    place_detail_allow_border_pin_abut: (bool):
                        # allow instance abut with its neighbors when it has pins near by the cell boundary
    place_detail_allow_single_height_row_symmetry_x: (string):
                        # allow single height row to be symmetryX
    place_detail_check_cut_spacing: (bool):
                        # Check via cut spacing during DRC checking
    place_detail_check_inst_space_group: (bool):
                        # check inst space group
    place_detail_check_route: (bool):
                        # do DRV checks against FIXED wires during legalization, along with preroutes
    place_detail_color_aware_legal: (bool):
                        # enable adjacent cell color conflict check in legalization
    place_detail_context_aware_legal: (enum):
                        # specify the types of cell context rules the placer needs to honor. The argument values [optional, required, user ignore_soft] can be used separately or combined, but they are exclusive to all | none (default=all)
    place_detail_eco_max_distance: (double):
                        # specify max distance (in micron) for refinePlace ECO mode
    place_detail_eco_priority_insts: (enum):
                        # select instance priority for refinePlace ECO mode
    place_detail_fixed_shifter: (bool):
                        # mark shifters FIXED once placed
    place_detail_honor_inst_pad: (bool):
                        # honor padding from set_inst_padding in detail placement
    place_detail_io_pin_blockage: (bool):
                        # ioPins from top-level are treated as pre-routes during DRV checks     in legalization
    place_detail_iraware_max_drive_strength: (double):
                        # This attribute is not directly used by Genus but instead, when set, is shared with Innovus.
    place_detail_irdrop_aware_effort: (enum):
                        # selects which IR drop optimization effort level to use during refinePlace
    place_detail_irdrop_aware_timing_effort: (enum):
                        # selects which timing effort level to use during refinePlace
    place_detail_irdrop_region_number: (int):
                        # value for debug_irdrop -nregion in native API
    place_detail_legalization_inst_gap: (int):
                        # minimum gap between instances (unit sites)
    place_detail_max_shifter_column_depth: (double):
                        # maximum distance from vertical power domain boundary that a shifter can be placed
    place_detail_max_shifter_depth: (double):
                        # maximum distance from a horizontal or vertical power domain boundary that a shifter can be placed
    place_detail_max_shifter_row_depth: (double):
                        # maximum distance from a horizontal power domain bounary that a shifter can be placed
    place_detail_no_filler_without_implant: (bool):
                        # there is no cell which  has no implant obs
    place_detail_pad_fixed_insts: (bool):
                        # honor cell-padding for FIXED instances in refinePlace
    place_detail_pad_physical_cells: (bool):
                        # padding overlap with physcial cells would be honored
    place_detail_preroute_as_obs: (string):
                        # specify layers on which preroute are taken as OBS
    place_detail_preserve_routing: (bool):
                        # do not delete routed wires during refinePlace
    place_detail_remove_affected_routing: (bool):
                        # delete only wires whose nets were touched due to moved cells
    place_detail_sdp_alignment_in_refine: (bool):
                        # call sdp alignment in every refinePlace
    place_detail_swap_eeq_cells: (bool):
                        # replace master cells by its EEQ cell during legalization, to keep max-dist move low
    place_detail_use_check_drc: (bool):
                        # Use FGC based DRC engine in legalization
    place_detail_use_diffusion_transition_fill: (bool):
                        # insert OD transition filler in 1X gap
    place_detail_use_gate_array_filler_groups: (bool):
                        # filler cell insts will only be replaced by logic insts that belong to same GA groups.
    place_detail_use_no_diffusion_one_site_filler: (bool):
                        # override -fillerGapMinGap to 0 and all source-drain spacing rule to 1 site during legalizing
    place_detail_wire_length_opt_effort: (enum):
                        # selects which wire-length optimization effort level to use during refinePlace
    place_global_activity_power_driven: (enum):
                        # identifies and constrains power-critical nets to reduce switching power
    place_global_activity_power_driven_effort: (enum):
                        # -place_global_activity_power_driven_effort mode
    place_global_align_macro: (bool):
                        # enable mixed-placer to align nearby same-size macros during global placement
    place_global_allow_3d_stack: (bool):
                        # This attribute is not directly used by Genus but instead, when set, is shared with Innovus.
    place_global_auto_blockage_in_channel: (enum):
                        # Placement will (temporarily) block channels between areas with limited routing capacity
    place_global_clock_gate_aware: (bool):
                        # find better placement for clock gating elements towards the center of gravity for fanout
    place_global_clock_power_driven: (bool):
                        # clock power driven
    place_global_clock_power_driven_effort: (enum):
                        # -place_global_clock_power_driven_effort mode
    place_global_cong_effort: (enum):
                        # level of effort for congestion driven global placer
    place_global_cpg_effort: (enum):
                        # level of effort for CPG
    place_global_cpg_file: (string):
                        # This attribute is not directly used by Genus but instead, when set, is shared with Innovus.
    place_global_enable_distributed_place: (bool):
                        # enable distributed placement platform
    place_global_ignore_scan: (enum):
                        # ignore scan net during placement
    place_global_ignore_spare: (bool):
                        # discard spare cell connections during global placement
    place_global_max_density: (double):
                        # placement strives to not let density exceed given value, in any part of design
    place_global_module_aware_spare: (bool):
                        # Spare insts are placed randomly along with the containing module's insts
    place_global_module_padding: (string):
                        # define the padding factor for the given module to reduce the local density and congestion
    place_global_place_io_pins: (bool):
                        # place IO Pins concurrently with std.cell placement, and do layer assignment
    place_global_reorder_scan: (bool):
                        # turn on reorder scan during placement
    place_global_sdp_alignment: (bool):
                        # ensure SDP alignment during placement
    place_global_sdp_place: (enum):
                        # honor SDP groups and places SDP cells closely during placement
    place_global_soft_guide_strength: (enum):
                        # level of effort for user definded softGuide for global placer
    place_global_timing_effort: (enum):
                        # level of effort for timing driven global placer
    place_global_uniform_density: (enum):
                        # enable even cell distribution for designs with less than 70% utilization
    place_hard_fence: (bool):
                        # honor fence and region constraints in refinePlace
    place_opt_post_place_tcl: (string):
                        # a tcl script to be sourced after initial placement and before preCTS optimization in place_opt_design
    place_opt_run_global_place: (enum):
                        # place opt run global place
    place_spare_update_timing_graph: (bool):
                        # update timing graph during place_spare_modules
    opt_add_always_on_feed_through_buffers: (bool):
                        # Activates adding Always On Feed Thru buffers
    opt_add_insts: (bool):
                        # Enables adding of new instances
    opt_new_inst_prefix: (string):
                        # Prefix string for name of new instances
    opt_new_net_prefix: (string):
                        # Prefix string for name of new nets
    opt_add_ports: (bool):
                        # Enables adding ports for optimal buffering
    opt_all_end_points: (bool):
                        # Enables the all end points optimization mode
    opt_allow_multi_bit_on_flop_with_sdc: (enum):
                        # allow merge or split works on flops which have SDC
    opt_allow_only_cell_swapping: (bool):
                        # Forces the post_route optimization to perform only same-size Vth swapping for timing improvements
    opt_consider_routing_congestion: (enum):
                        # Enables routing congestion check at the post_route stage during optimization of setup, hold, drv, & glitch. It also impacts post_cts hold fixing.
    opt_delete_insts: (bool):
                        # Enables instance deletion on all paths
    opt_add_repeater_report_failure_reason: (bool):
                        # To enable printing detailed failure reason report file for addRepeaterByRule
    opt_detail_drv_failure_reason: (bool):
                        # To enable printing detailed drv failure reason report file
    opt_detail_drv_failure_reason_max_num_nets: (int):
                        # Specify how many violating nets printed
    opt_down_size_insts: (bool):
                        # Enables instance downsizing
    opt_drv_margin: (double):
                        # Used for scaling max cap/max tran constraints
    opt_enable_data_to_data_checks: (enum):
                        # enable library data to data checks during optimization for gigaopt
    opt_post_route_fix_clock_drv: (bool):
                        # enables DRV fixing on clock net
    opt_fix_fanout_load: (bool):
                        # Enables fixing fanOut load violations
    opt_post_route_fix_glitch: (bool):
                        # Enables glitch fixing in AAE flow
    opt_post_route_fix_si_transitions: (bool):
                        # Enables sislew fixing in AAE flow
    opt_hold_target_slack: (double):
                        # Specifies target slack value (in nano secs) for hold timing optimization
    opt_honor_density_screen: (bool):
                        # Control density screen
    opt_honor_fences: (bool):
                        # Specifies that the timing optimization takes fences constraints into account. Placement of cells will be legalized within each fence.
    opt_max_density: (double):
                        # Specifies maximum area utilization
    opt_max_length: (double):
                        # Enables max length constraints in opt_design
    opt_multi_bit_flop_merge_timing_effort: (enum):
                        # Timing effort level for MBFF merging
    opt_multi_bit_flop_split_timing_effort: (enum):
                        # Timing effort level for MBFF splitting
    opt_move_insts: (bool):
                        # Enables moving instances while fixing setup violations
    opt_multi_bit_combinational_merge_timing_effort: (enum):
                        # Specifies the timing effort level for multibit combinational merging
    opt_multi_bit_combinational_opt: (enum):
                        # enables or disables the multi-bit combinational optimization flow
    opt_multi_bit_combinational_split_timing_effort: (enum):
                        # Specifies the timing effort level for multibit combinational splitting
    opt_multi_bit_flop_name_prefix: (string):
                        # User to specify multi bit flop name prefix
    opt_multi_bit_flop_name_separator: (string):
                        # User to specify flop merge and split name separator
    opt_multi_bit_flop_name_suffix: (string):
                        # User to specify multi bit flop name suffix, For example: _FF
    opt_multi_bit_flop_opt: (enum):
                        # specifies multi bit flop merge/split opt
    opt_multi_bit_flop_reorder_bits: (enum):
                        # Enable Swap MBFF bits to take advantage of mixed-drving stength cells. false: Disable; true: enable for timing and power optimization; timing: enable for timing optimization; power: enable for power optimization.
    opt_pre_route_ndr_aware: (string):
                        # Provide a list of NDR names that will be used NDR-based optimization
    opt_constant_inputs: (bool):
                        # Force optimization of instances with constant inputs, even if it worsens objective gain
    opt_constant_nets: (bool):
                        # Enables optimization of constant nets
    opt_resize_flip_flops: (bool):
                        # Enables FF resizing
    opt_tied_inputs: (bool):
                        # Force optimization of instances with inputs tied together, even if it worsens objective gain
    opt_post_route_allow_overlap: (bool):
                        # Enables post_route optimization to insert cells with overlaps when inadequate free space is available. The placement will then be legalized before ECO routing.
    opt_post_route_area_reclaim: (enum):
                        # To enable area reclaim in post_route optimization
    opt_post_route_check_antenna_rules: (bool):
                        # Allows optimization to check/ignore antenna rules in lefsafe swaps
    opt_post_route_drv_recovery: (enum):
                        # Enables post_route drv recovery in gigaopt.
    opt_post_route_hold_recovery: (enum):
                        # This attribute is not directly used by Genus but instead, when set, is shared with Innovus.
    opt_post_route_setup_recovery: (enum):
                        # Enables post_route SI setup timing recovery in gigaopt.
    opt_power_effort: (enum):
                        # Effort level for power aware mode in optimization
    opt_preserve_all_sequential: (bool):
                        # Preserve sequential element during the simplify netlist optimization step
    opt_preserve_hpin_function: (bool):
                        # Enables preserving logical functions at hierarchical ports
    opt_area_recovery: (enum):
                        # Enables area reclamation step
    opt_multi_bit_flop_split_report_failure_reason: (bool):
                        # To enable printing split failure reasons
    opt_resize_power_switch_insts: (bool):
                        # Enables resizing of power switch instances during optimization
    opt_resize_level_shifter_and_iso_insts: (bool):
                        # Enables resizing of shifters and isolation instances
    opt_enable_restructure: (bool):
                        # Enables netlist restructuring
    opt_sequential_genus_restructure_report_failure_reason: (bool):
                        # To enable printing SeqCRR failure reasons
    opt_setup_target_slack: (double):
                        # Specifies target slack value (in nano secs) for setup timing optimization
    opt_area_recovery_setup_target_slack: (double):
                        # Specifies target slack value (in nano secs) for area and power reclaim during setup timing optimization
    opt_flop_pins_report: (enum):
                        # print full hierarchical flop pins names for flops deleted in simplifyNetlist
    opt_flops_report: (enum):
                        # print full hierarchical flop names for flops deleted in simplifyNetlist
    opt_remove_redundant_insts: (bool):
                        # Enables simplifying the netlist during optimization
    opt_pin_swapping: (bool):
                        # Enables pin swapping
    opt_target_based_opt_file: (string):
                        # Target based opt input file
    opt_target_based_opt_file_only: (enum):
                        # Use data from target based opt file for optimization
    opt_target_based_opt_hold_file: (string):
                        # Target based opt input file for hold
    opt_time_design_compress_reports: (bool):
                        # save reports in compressed format
    opt_time_design_expanded_view: (bool):
                        # To report expanded views in time_design
    opt_time_design_num_paths: (int):
                        # Report specified number of paths in time_design
    opt_time_design_report_net: (bool):
                        # To report net delays in time_design
    opt_unfix_clock_insts: (bool):
                        # Enables unfixing clock instances flow
    opt_concatenate_default_and_user_prefixes: (bool):
                        # Enables combining default prefix for instances(nets) with the prefix specified by opt_new_inst_prefix(opt_new_net_prefix)
    opt_post_route_art_flow: (bool):
                        # Enables optimizing the top-level interface logic for a hierarchical floorplan
    opt_drv: (bool):    # Enables fixing max cap/max tran violations on constrained nets
    opt_hold_allow_overlap: (enum):
                        # Enables hold optimization to insert cells with overlaps when inadequate free space is available. The placement will then be legalized before ECO routing.
    opt_hold_allow_setup_tns_degradation: (bool):
                        # Allows setup total negative slack to degrade during hold optimization.
    opt_hold_on_excluded_clock_nets: (bool):
                        # Do hold fixing on the excluded clock nets
    opt_drv_with_miller_cap: (bool):
                        # This attribute is not directly used by Genus but instead, when set, is shared with Innovus.
    opt_high_effort_cells: (string):
                        # Provide a list of cells to be used for high effort optimization. Dont-use and Dont-touch constraints for these cells will be ignored for high effort optimization.
    opt_hold_cells: (string):
                        # Provide a list of buffer & delay cells to be used for hold buffering. The dont_use constraints for these cells will be ignored.
    opt_hold_slack_threshold: (double):
                        # Specifies target slack value (in nano secs) for hold timing optimization
    opt_hold_ignore_path_groups: (string):
                        # Specifies path groups to be excluded in hold timing optimization
    opt_skew: (bool):   # Enables triggering the skew_clock command from within opt_design
    opt_skew_post_route: (bool):
                        # Enables useful skew optimization during post_route timing optimization.
    opt_skew_pre_cts: (bool):
                        # Enables useful skew optimization during pre_cts timing optimization.
    opt_skew_ccopt: (enum):
                        # Effort for useful skew optimization within ccopt_design
    opt_verbose: (bool):
                        # Enables verbose information logging
    opt_hold_allow_resize: (enum):
                        # Enables the resizing capability inside hold optimization.
    route_early_global_effort_level: (enum):
                        # Specifies the congestion effort level. Default is "standard", where congestion is more accurate and runtime is larger. If set to "medium", runtime will be much smaller and congestion report will have less accuracy. Setting to "low", it will be faster than "medium" however less accurate.
    route_early_global_honor_power_domain: (bool):
                        # consider MSV constraints while routing
    route_early_global_reverse_direction_regions: (string):
                        # Reverse routing direction in the given region on the specified layer-range. Example: "(x1 y1 x2 y2) M1:M2 (x3 y3 x4 y4) M3:M4 ..."
    route_early_global_honor_partition_allow_feedthru: (string):
                        # Honor partition fences with feedthrough for <list_of_ptn_cell_names>.
    route_early_global_honor_partition_fence: (string):
                        # Honor partition fences for <list_of_ptn_cell_names>.
    route_early_global_honor_partition_pin: (string):
                        # Honor partition fences and single-entry constraint for <list_of_ptn_cell_names>.
    route_early_global_honor_partition_pin_guide: (bool):
                        # Honor partition pin guides. Default is true
    route_early_global_route_selected_net_only: (bool):
                        # Only route the nets which are selected in the DB.
    route_early_global_stripe_layer_range: (string):
                        # Route secondary PG pins to access to the PG stripes in the given layer range.
    route_early_global_secondary_pg_max_fanout: (int):
                        # Specifies the max fanout limit for each secondary PG subnet
    route_design_adjust_auto_via_weight: (bool):
                        # adjust auto via weight for via swapping
    route_design_allow_inst_overlaps: (bool):
                        # don't do instance overlap check
    route_design_ignore_follow_pin_shapes: (bool):
                        # Ignore follow pin via shapes
    route_design_process_node: (string):
                        # Specify the process node
    route_design_rc_extraction_corner: (string):
                        # specific which RC extraction corner to use in routing
    route_design_skip_analog: (bool):
                        # skip routing nets or pins marked + USE ANALOG in the DEF file
    route_design_via_weight: (string):
                        # set weight for vias
    route_design_detail_add_passive_fill_only_on_layers: (string):
                        # specify layers where passive fill will be added
    route_design_detail_allow_passive_fill_only_in_layers: (string):
                        # specify layers where do passive fill only
    route_design_detail_antenna_eco_list_file: (string):
                        # set file name for antenna eco list
    route_design_detail_auto_stop: (bool):
                        # control whether Nanoroute continues routing if there are many violations
    route_design_detail_check_mar_on_cell_pin: (bool):
                        # Enable mar checking on used cell pins
    route_design_detail_end_iteration: (int):
                        # specify the last iteration pass in a detailed routing step
    route_design_detail_fix_antenna: (bool):
                        # fix antenna violation by jumping metal layers
    route_design_detail_fix_antenna_on_secondary_pg_nets: (bool):
                        # fix antenna violation on sencondary pg nets
    route_design_detail_fix_antenna_with_gate_array_filler_mode: (bool):
                        # detect GA filler flow while doing antenna violation fixing
    route_design_detail_merge_abutting_cut: (bool):
                        # merge two abutting cell cut shapes into a new one
    route_design_detail_min_length_for_spread_wire: (string):
                        # specify the min. length of a spreaded wire
    route_design_detail_min_length_for_widen_wire: (double):
                        # specify the min. length of a widened wire
    route_design_detail_min_slack_for_opt_wire: (double):
                        # specify the min slack for a net wire optimization
    route_design_detail_no_taper_in_layers: (string):
                        # Specifies the range of the layer where taper is not allowed
    route_design_detail_no_taper_on_output_pin: (enum):
                        # forbid wire tapering at output pin
    route_design_detail_on_grid_only: (string):
                        # route on grid only
    route_design_detail_post_route_litho_repair: (bool):
                        # litho hotspot repair in post route stage
    route_design_detail_post_route_spread_wire: (string):
                        # spread wire in post route stage
    route_design_detail_post_route_swap_via: (string):
                        # to enforce post route via swapping mode in detail route command.
    route_design_detail_postroute_via_priority: (string):
                        # Set net priority for via swapping based on timing
    route_design_detail_post_route_via_pillar_effort: (string):
                        # Set opt effort/range for opportunistic via pillar
    route_design_detail_post_route_wire_widen: (string):
                        # widen wire in post route stage
    route_design_detail_post_route_wire_widen_rule: (string):
                        # specify the rule used to widen wire
    route_design_detail_search_and_repair: (bool):
                        # run search-and-repair step after the initial detailed routing
    route_design_detail_signoff_effort: (string):
                        # specify when to give up on irresolvable violations
    route_design_detail_stub_routing_in_first_layer: (bool):
                        # to use Minimum routing in the first routing layer defined in the LEF
    route_design_detail_use_multi_cut_via_effort: (string):
                        # specify the effort to use multi-cut via during routing
    route_design_number_fail_limit: (int):
                        # set limit for number of fails
    route_design_number_thread: (int):
                        # set the number of processors to be used in one workstation for multi-threading
    route_design_number_warning_limit: (int):
                        # set limit for number of warnings
    route_design_third_party_data: (bool):
                        # Allow third party data as input
    route_design_high_freq_constraint_groups: (string):
                        # only route specified constraint groups, legal values are {net match bus pair shield}, add "order" in front to control route order
    route_design_high_freq_match_report_file: (string):
                        # specify match report file name
    route_design_high_freq_num_reserved_layers: (int):
                        # number of layers reserved for standard cell pin access
    route_design_high_freq_remove_floating_shield: (bool):
                        # remove floating shield segments for high frequency nets
    route_design_high_freq_search_repair: (string):
                        # run search and repair to remove violations, legal value is one of {auto false true only}
    route_design_high_freq_shield_trim_length: (double):
                        # specify minimum length of shielding wire to be kept
    route_design_high_freq_trans_pin_access: (string):
                        # transitional pin access {auto false true only}
    route_design_interposer_allow_diagonal_trunk: (string):
                        # allow_diagonal_trunk
    route_design_interposer_interlayer_shielding_layers: (string):
                        # interlayer shielding layers
    route_design_interposer_interlayer_shielding_nets: (string):
                        # interlayer shielding nets
    route_design_interposer_interlayer_shielding_offsets: (string):
                        # interlayer shielding offsets
    route_design_interposer_interlayer_shielding_widths: (string):
                        # interlayer shielding widths
    route_design_interposer_same_layer_shielding_net: (string):
                        # same_layer_shielding_net
    route_design_interposer_same_layer_shielding_width_spacing: (string):
                        # same_layer_shielding_width_spacing
    route_design_interposer_trunk_routing_layers: (string):
                        # trunk_routing_layers
    route_design_interposer_trunk_routing_width_spacing: (string):
                        # trunk_routing_width_spacing
    route_design_add_antenna_inst_prefix: (string):
                        # prefix for the diode insts added to fix antenna
    route_design_allow_pin_as_feedthru: (enum):
                        # allow pin as feedthrough
    route_design_antenna_cell_name: (string):
                        # specify the antenna diode cell names for antenna fixing
    route_design_concurrent_minimize_via_count_effort: (string):
                        # specify the effort of concurrent via minimization
    route_design_connect_to_bumps: (bool):
                        # connect to bumps in native NanoRoute in Innovus
    route_design_fix_clock_nets: (bool):
                        # set clock nets routing status to fixed or routed
    route_design_route_clock_nets_first: (bool):
                        # route clock nets first
    route_design_eco_ignore_existing_route: (string):
                        # Ignore existing route in eco, mode: {all | signal}
    route_design_enable_route_rule_si_limit_length: (string):
                        # use MAR wire length as NDR PRL requirement for metal spacing check
    route_design_enforce_route_rule_on_special_net_wire: (string):
                        # enforce ndr rule on all special wire segments of specified nets
    route_design_extra_via_enclosure: (double):
                        # specify an extra via enclosure to use when connecting to block pins and special net wires
    route_design_honor_exclusive_region: (bool):
                        # honor exclusive region routing
    route_design_honor_power_domain: (bool):
                        # honor power domain routing
    route_design_ignore_antenna_top_cell_pin: (bool):
                        # ignore antenna check on block I/O pins
    route_design_antenna_diode_insertion: (bool):
                        # insert antenna diode to fix antenna violation
    route_design_diode_insertion_for_clock_nets: (bool):
                        # allow diode insertion on clock nets
    route_design_shield_tap_cell_insertion: (bool):
                        # insert tap cell for shielding
    route_design_relaxed_route_rule_spacing_to_power_ground_nets: (string):
                        # relax the spacing requirement from NDR spacing for the layers
    route_design_reserve_space_for_multi_cut: (bool):
                        # Reserves space to insert multicut vias in postroute stage. This option has to be set before routing. After routing with this parameter specified, you can add double-cut vias or larger overhang vias by using the "route_design -via_opt" command. For examples, see route_design.
    route_design_reverse_direction: (string):
                        # reverse routing direction in area: (lx ly ux uy [bot_lyr : top_lyr]) ... , top_lyr and bot_lyr could be either layer name or layer routing id
    route_design_selected_net_only: (bool):
                        # route selected net only
    route_design_shield_crosstie_offset: (string):
                        # Specifies the offset in terms of number of tracks for adding crossties. The default is 0 for all layers. The syntax is 'layer_name:numTrack1 layer_name2:numTrack2... '.
    route_design_shield_report_skip_status: (bool):
                        # generate report file on if a net is skipped for shielding
    route_design_shield_tap_cell_name: (string):
                        # specify the tap cell names for shielding
    route_design_strict_honor_route_rule: (string):
                        # Strictly enforce non-default rules
    route_design_stripe_layer_range: (string):
                        # specify the target layer range of stripes for tie net connection
    route_design_tieoff_to_shapes: (string):
                        # specify the target special wire shapes or target instance pin for tie net connection: [auto stripe ring powergroundpin]
    route_design_trim_pull_back_distance_from_boundary: (string):
                        # route_trim_pull_back_distance_from_boundary {<layer>:<value> ...}
    route_design_trunk_with_cluster_target_size: (int):
                        # global control of trunk routing pattern for nets with TRUNK pattern attribute. 0: nets with TRUNK pattern will be routed as Steiner tree; 1: default, nets will be routed as traditional trunk pattern, i.e., each pin directly connects to SNET trunk separately; >1: define a proximate max cluster size (in number of pins), and nets will be routed as fishbone style, i.e., several pins in a column are clustered together, and then connects to SNET trunk.
    route_design_unconnected_ports: (bool):
                        # Route unconnected ports
    route_design_use_auto_via: (string):
                        # allow to use internal generated vias
    route_design_with_eco: (bool):
                        # enable eco routing
    route_design_with_litho_driven: (bool):
                        # enable the litho-driven routing
    route_design_with_si_driven: (bool):
                        # enable si driven routing
    route_design_with_timing_driven: (bool):
                        # enable timing driven routing
    route_design_with_trim_metal: (string):
                        # set cut metal dgrid for short pin extension generated
    route_design_with_via_in_pin: (string):
                        # enclose via in pin shape
    route_design_with_via_only_for_block_cell_pin: (string):
                        # enclose via in pin shape for macro cell pins
    route_design_with_via_only_for_stdcell_pin: (string):
                        # disable planar access to standard cell pins
    delaycal_accuracy_level: (int):
                        # set accuracy level for delay calculation
    delaycal_advanced_node_pin_cap_settings: (bool):
                        # Enable advanced node pin cap settings.
    delaycal_advanced_pin_cap_mode: (enum):
                        # Enable advanced receiver pin cap mode for base delay.
    delaycal_combine_mmmc: (enum):
                        # Specifies whether delay calculation runs are to be combined for delay calculation simulations
    delaycal_early_irdrop_data_type: (enum):
                        # IRDrop EIV DB EivMethod for early corner
    delaycal_enable_high_fanout: (bool):
                        # Enables the default net delay which will be annotated on high fanout nets
    delaycal_enable_quiet_receivers_for_hold: (bool):
                        # This attribute is not directly used by Genus but instead, when set, is shared with Innovus.
    delaycal_equivalent_waveform_model_for_timing_check: (bool):
                        # Enable EWM for timing check delay.
    delaycal_honor_slew_propagate_constraint: (bool):
                        # Determines whether to propagate the slew from the disabled timing arcs to the output pin.
    delaycal_ignore_net_load: (bool):
                        # Uses zero-cap, zero-resistance wire-load model for estimating delays.
    delaycal_irdrop_data_type: (enum):
                        # IRDrop EIV DB EivMethod
    delaycal_irdrop_window_based: (enum):
                        # Fetch window based EIV values from EIV DB
    delaycal_late_irdrop_data_type: (enum):
                        # IRDrop EIV DB EivMethod for late corner
    delaycal_library_interpolation_mode: (enum):
                        # library scaling mode for interpolation flow
    delaycal_report_out_bound: (bool):
                        # Generates a report that contains a list of index values (input transition) in the delay tables that are beyond the index range.
    delaycal_write_set_inst_voltage_cmd: (bool):
                        # Enable set_inst_voltage cmd saving in persistant db
    delaycal_enable_si: (enum):
                        # Enables SIAware delay calculation that also includes cross-talk induced delays.
    delaycal_signoff_alignment_settings: (bool):
                        # Turn on/off signoff alignment settings
    delaycal_skip_slew_merge_from_disabled_path: (bool):
                        # Enable slew merge from disable path
    delaycal_slew_out_bound_limit_high: (double):
                        # Limits the maximum slew used in the analysis to the specified value.
    delaycal_slew_out_bound_limit_low: (double):
                        # Limits the minimum slew used in the analysis to the specified value.
    delaycal_socv_accuracy_mode: (enum):
                        # level-based-accuracy-effort in AAE for delays and slews
    delaycal_socv_machine_learning_level: (int):
                        # Enable socv machine learning mode
    delaycal_equivalent_waveform_type: (enum):
                        # Equivalent waveform model type to be used
    reorder_scan_add_scan_port_prefix: (string):
                        # prefix of scan hport
    reorder_scan_allow_swapping: (bool):
                        # reorder with new swap mode
    reorder_scan_clock_aware: (bool):
                        # Clock tree aware reorder
    reorder_scan_comp_logic: (bool):
                        # trace considering multiple input logic
    reorder_scan_enable_for_partition: (bool):
                        # enable scanReorder for design with partition
    reorder_scan_keep_hport: (bool):
                        # Maintains hierarchical ports without adding or deleting shifters
    reorder_scan_keep_hinst_port_name: (string):
                        # Specifies filename which contains HInsts
    reorder_scan_prefer_horizontal: (bool):
                        # Makes horizontal scan chain connections if possible
    reorder_scan_prefer_vertical: (bool):
                        # Makes vertical scan chain connections if possible
    reorder_scan_effort: (enum):
                        # Specifies effort level for reorder_scan
    reorder_scan_skip_mode: (enum):
                        # Specifies method for handling buffers and inverters
    reorder_scan_swap_effort: (enum):
                        # Specifies effort level for reorder_scan different chains swapping
    add_fillers_cell_name_style: (enum):
                        # Add physical cells into hierarchical modules, or as top level cells (flat)
    design_compressed_pg_db: (bool):
                        # Specifies whether the compressed pg feature is enabled. When it's true, read_db will automatically compress the PG data when load the design. You can use "get_db current_design .is_pg_compressed" to check if PG in this design is compressed.
    design_cong_effort: (enum):
                        # Specify congestion effort level
    design_dual_rail_via_pitch: (string):
                        # Min stacked-via pitch for dual std-cell power-rails on first and third routing layers. Space separated min stacked-via pitch for dual std-cell power-rails on first and third routing layers.
    design_early_clock_flow: (bool):
                        # Enable early clock flow
    design_express_route: (bool):
                        # With "-flow_effort express", should routing-stage be forced.
    design_ignore_followpin_vias: (bool):
                        # if true, ignore followpin vias during detailed placement, optimization and routing.
    design_tech_node: (enum):
                        # set design tech node
    design_pessimistic_mode: (enum):
                        # Enable pessimistic mode
    design_slack_weighting_method: (enum):
                        # Specify slack weighting to be used in implementation flow
    design_trim_grid_group: (string):
                        # Specifies the GROUP name of which set of trim metal grid to be used for placement and routing. See the LEF documentation on the TRIMMETALTRACK keyword for more details.
    timing_analysis_aocv: (bool):
                        # AOCV Analysis
    timing_analysis_async_checks: (enum):
                        # Async checks
    timing_analysis_case_analysis: (bool):
                        # caseAnalysis
    timing_analysis_check_type: (enum):
                        # Report Violations for hold, setup
    timing_analysis_clock_net_marking_mode: (enum):
                        # clkNetsMarking
    timing_analysis_clock_gating: (bool):
                        # clockGatingCheck
    timing_analysis_cppr: (enum):
                        # Removes pessimism from clock paths that have a portion of the clock network in common between the clock source and clock destination paths
    timing_analysis_honor_active_logic_view: (bool):
                        # Honor Active Logic View
    delaycal_degrade_slew_on_early_nets: (bool):
                        # Controls interconnect slew degradation for early paths.
    timing_analysis_socv: (bool):
                        # SOCV Analysis
    timing_analysis_engine: (enum):
                        # Statistical or Static or Rql
    delaycal_support_output_pin_cap: (bool):
                        # useOutputPinCap
    opt_skew_delay_pre_cts: (bool):
                        # delaying mode in pre_cts
    opt_skew_macro_only: (bool):
                        # skew hard blocks
    opt_skew_max_allowed_delay: (double):
                        # max allowed skewing delay, unit is 'ns'
    opt_skew_min_allowed_delay: (double):
                        # min allowed skewing delay, unit is 'ns'
    opt_skew_no_boundary: (bool):
                        # consider boundary sequential elements
    floorplan_check_types: (enum):
                        # Specify the check types for check_floorplan. Default is the basic.
    floorplan_cut_off_place_blockage_outside_die: (bool):
                        # When creating placement blockages, will cut the part outside of die and snap it by default.
    floorplan_cut_off_route_blockage_outside_die: (bool):
                        # When creating routing blockages around inst/Hinst/Partition, will cut the part outside of die and snap it by default. If this option is set to false, don't cut and snap it.
    floorplan_default_power_domain_site: (bool):
                        # Create rows based on default power domain site instead of the design?s default site.
    floorplan_enable_rectilinear_design: (bool):
                        # Specify whether design boundary can be changed to rectilinear shape.
    floorplan_include_io_when_init_area: (bool):
                        # Include IO cells when calculating the area of modules.
    floorplan_initial_all_compatible_core_site_rows: (bool):
                        # If true, initCoreRow will create all SITE with type core. 
    floorplan_keep_rows_when_moving_power_domain: (bool):
                        # specify whether to keep all existing rows in disjoint power domain when moving, resizing or reshaping a power domain on GUI or by command. 
    floorplan_max_io_height: (bool):
                        # Use maximum IO height to calculate a die box with IO placement. By default, minimum IO height is used.
    floorplan_minimum_sites: (int):
                        # Specify the number of minimal sites (N) that check_floorplan will check for the same length site rule. When same_length_site is specified in floorplan_check_types, this option is required.
    floorplan_move_macros_with_constraint: (enum):
                        # Specify macros move with constraint modules at the same time.
    floorplan_move_preplaced_std_cell_only: (bool):
                        # Specify only pre-placed std cells move with constraint modules at the same time.
    floorplan_move_std_cell_with_constraint: (enum):
                        # Specify std cells move with constraint modules at the same time.
    floorplan_narrow_channel_threshold: (double):
                        # Reports narrow channels whose width (in micros) is smaller than the specified value. When narrow_channel is specified in floorplan_check_types, this option is required.
    floorplan_no_cut_row: (bool):
                        # Specify no need to do cut row before other operations.
    floorplan_power_rail_layer: (string):
                        # Specify the layers for calculating power/ground on bottom attribute of cell or techsite. By default, the lowest metal layer is used.
    floorplan_row_site_height: (enum):
                        # Specify the odd even row height constraints.
    floorplan_row_site_width: (enum):
                        # Specify the odd even row width constraints.
    floorplan_snap_all_corners_to_grid: (bool):
                        # Specify to snap all corners of object to grid.
    floorplan_snap_block_grid: (enum):
                        # Specify the block snap rules. It can be set to snap to manufacture grid, instance grid, placement grid, user-define grid, layer_track grid, finfet manufacture grid, finfet instance grid, finfet placement grid. The default is manufacturing_grid. For Finfet design, the default is finfet_manufacturing_grid.
    floorplan_snap_constraint_grid: (enum):
                        # Specify the constraint snap rules. It can be set to snap to manufacture grid, instance grid, placement grid, user-define grid, layer_track grid, finfet manufacture grid, finfet instance grid, finfet placement grid. The default is inst_grid. For Finfet design, the default is finfet_inst_grid.
    floorplan_snap_core_grid: (enum):
                        # Specify the core snap rules. It can be set to snap to manufacture grid, instance grid, placement grid, user-define grid, layer_track grid, finfet manufacture grid, finfet instance grid, finfet placement grid. The default is placement_grid. For Finfet design, the default is finfet_placement_grid.
    floorplan_snap_die_grid: (enum):
                        # Specify the die snap rules. It can be set to snap to manufacture grid, instance grid, placement grid, user-define grid, layer_track grid, finfet manufacture grid, finfet instance grid, finfet placement grid. The default is placement_grid. For Finfet design, the default is finfet_placement_grid.
    floorplan_snap_io_grid: (enum):
                        # Specify the IO snap rules. It can be set to snap to manufacture grid, instance grid, placement grid, user-define grid, layer_track grid, finfet manufacture grid, finfet instance grid, finfet placement grid. The default is manufacturing_grid. For Finfet design, the default is finfet_manufacturing_grid.
    floorplan_snap_place_blockage_grid: (enum):
                        # Specify the placement blockage snap rules. The default is inst_grid.
    floorplan_user_define_grid: (rect):
                        # Specify the user-define grid. Format is {x_offset y_offset x_pitch y_pitch}. The x_offset y_offset is the offset of user-define grid. The x_pitch separates the vertical grid lines. The y_pitch separates the horizontal grid lines. The values are in microns.
    power_intent_allow_nested_default_domain: (bool):
                        # Allows a non-default power domain member to be logically nested in a default power domain
    power_intent_allow_power_domain_min_gap_zero: (bool):
                        # This attribute is not directly used by Genus but instead, when set, is shared with Innovus.
    power_intent_check_all_nets_for_domain_crossing: (bool):
                        # Checks all the nets for domain crossings
    power_intent_allow_back_to_back_isolation: (bool):
                        # Supports back-to-back isolation insertion along cross-domain net based on power intent ISO rule
    power_intent_honor_power_domain_for_intra_domain_route: (bool):
                        # To route intra-power domain nets only within their power domains
    power_intent_honor_power_domain_for_domain_crossing_route: (bool):
                        # to handle nets belong to multiple power domains
    power_intent_use_cpf_global_connect_for_always_on_buffer: (bool):
                        # Honors connection specs for AO buffer based on the power intent rules
    power_intent_use_cpf_global_connect_for_shifter: (bool):
                        # Honors connection specs for shifters based on the CPF rules
    power_intent_include_dot_lib_related_pg_pin: (bool):
                        # Honors timing library related PG pins
    power_intent_use_effective_domain_for_iso_shifter_insertion: (bool):
                        # Honors effective domains for ISO/LS insertions
    power_intent_assume_iso_enable_pin_is_always_on: (bool):
                        # To mark all Isolation cell's enable pin as always on
    power_intent_do_not_use_top_domain_for_port_voltage: (bool):
                        # Controls voltage using top fterm domain for IO pin voltage
    power_intent_share_well_always_on_buffering_support: (bool):
                        # This attribute is not directly used by Genus but instead, when set, is shared with Innovus.
    power_intent_allow_shifter_voltage_mismatch: (bool):
                        # This attribute is not directly used by Genus but instead, when set, is shared with Innovus.
    win_fp_inst_threshold: (int):
                        # Instance count threshold for modules to be floorplan-ed.
@genus:root: 3> exit

Lic Summary:
[13:10:32.002712] Cdslmd servers: europa
[13:10:32.002728] Feature usage summary:
[13:10:32.002728] Genus_Synthesis

Normal exit.